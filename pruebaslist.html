<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pruebas guardadas</title>
    <link rel="stylesheet" href="style.css">
    <style>
      /* Encabezado fijo para el listado principal de pruebas */
      #tabla-pruebas-listado thead {
        position: sticky;
        top: 0;
        z-index: 6;
        background: #f3f4f6;
      }
      #tabla-pruebas-listado thead th {
        position: sticky;
        top: 0;
        z-index: 7;
        background: #f3f4f6; /* mismo tono ya usado */
        box-shadow: 0 1px 0 0 #e5e7eb;
      }

      /* Barra de acciones (eliminar/exportar) fija al hacer scroll de p√°gina */
      .sticky-list-toolbar {
        position: sticky;
        top: 60px; /* bajo el header y la zona superior */
        z-index: 9;
        background: #ffffff;
        padding-top: 0.25rem;
        padding-bottom: 0.25rem;
      }

      /* Hacer el listado un panel scrollable para mantener visible su encabezado */
      .listado-scroll {
        overflow: auto;
        max-height: calc(100vh - 280px);
      }

      /* Chips de per√≠odo (arriba del Resumen) con estilo neutro gris y efecto activo */
      .chips-periodo .chip {
        background: #f8fafc; /* gris claro */
        border: 1px solid #e5e7eb;
        color: #111827;
        box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        background-image: none; /* elimina l√≠nea/gradiente superior si existiera */
        position: relative; /* para la l√≠nea superior */
        overflow: hidden;
      }
      /* Asegura que no se vea ninguna l√≠nea superior heredada */
      .chips-periodo .chip::before {
        content: none !important;
        display: none !important;
      }
      .chips-periodo .chip:hover {
        box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      }
      /* Resalta activo (el JS ya alterna dataset.active) */
      .chips-periodo .chip[data-active="1"] {
        box-shadow: 0 0 0 2px #2563eb inset; /* efecto active */
        font-weight: 700;
      }

    </style>
</head>
<body>
    <header>
        <div class="logo">
            <img src="img/logopctch.png" alt="Logo PCT">
        </div>
        <button class="nav-toggle" type="button" aria-label="Abrir men√∫">
            &#9776;
        </button>
        <nav class="nav-main">
            <ul>
                <li><a href="index.html">Inicio</a></li>

                <li class="nav-item-has-dropdown">
                    <a href="#" class="active">Pruebas</a>
                    <ul class="nav-dropdown">
                        <li><a href="pruebas.html">Registrar prueba</a></li>
                        <li><a href="pruebaslist.html">Listado de pruebas</a></li>
                    </ul>
                </li>

                <li class="nav-item-has-dropdown">
                    <a href="#">Inspecciones</a>
                    <ul class="nav-dropdown">
                        <li><a href="inspeccion.html">Nueva inspecci√≥n</a></li>
                        <li><a href="inspectlist.html">Listado de inspecciones</a></li>
                    </ul>
                </li>

                <li class="nav-item-has-dropdown">
                    <a href="#">Actividad</a>
                    <ul class="nav-dropdown">
                        <li><a href="actividad.html">Registrar actividad</a></li>
                        <li><a href="actividadlist.html">Listado de actividades</a></li>
                        <li><a href="actividadmin.html" class="nav-admin-only">Administraci√≥n</a></li>
                        <li><a href="trazabilidades.html" class="nav-admin-only">Trazabilidades</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
        <div class="user-info">
            <span class="user-info-email" id="nav-user-email"></span>
            <button id="btn-logout">Salir</button>
        </div>
    </header>

    <main style="max-width: 100%; margin: 0; padding: 0;">
        <section class="pruebaslist-wrap" style="padding: 0.75rem 0.75rem 1rem;">
            <h1 style="text-align:center; font-size:2.25rem; font-weight:800; letter-spacing:0.02em; margin:0.25rem 0 0.75rem; color:#111827;">
                VISOR DE PND Y CALIBRACIONES
            </h1>
            <section id="seccion-chips-alertas" style="margin-bottom: 0.75rem;">
                <div style="display:flex; flex-wrap:wrap; gap:1rem; align-items:center; justify-content:center; font-size:1rem;">
                    <div id="chip-gt60" class="chip chip-large chip-green" style="cursor:pointer;">
                        > 60 d√≠as: <strong id="pruebas-alert-gt60">0</strong>
                    </div>
                    <div id="chip-60" class="chip chip-large chip-blue" style="cursor:pointer;">
                        60‚Äì31 d√≠as: <strong id="pruebas-alert-60">0</strong>
                    </div>
                    <div id="chip-30" class="chip chip-large chip-amber" style="cursor:pointer;">
                        30‚Äì16 d√≠as: <strong id="pruebas-alert-30">0</strong>
                    </div>
                    <div id="chip-15" class="chip chip-large chip-red" style="cursor:pointer;">
                        15‚Äì1 d√≠as: <strong id="pruebas-alert-15">0</strong>
                    </div>
                    <div id="chip-0" class="chip chip-large chip-black" style="cursor:pointer;">
                        üíÄ 0 d√≠as (vencidas): <strong id="pruebas-alert-0">0</strong>
                    </div>
                </div>
            </section>
            <p style="text-align:center; font-size:0.85rem; color:#6b7280; margin-top:0.25rem; margin-bottom:0.75rem;">
                Los rangos anteriores aplican √∫nicamente a pruebas <strong>ANUALES</strong>. Las pruebas de <strong>Post-trabajo</strong> y <strong>Reparaci√≥n</strong> siempre se muestran en el listado; sus chips sirven para filtrar por per√≠odo.
            </p>
        <!-- Chips de per√≠odo centrados antes del Resumen de estado -->
        <section id="seccion-chips-periodo" style="margin: 0 0 0.75rem; display:flex; justify-content:center;">
            <div class="chips-periodo" style="display:flex; flex-wrap:wrap; gap:0.5rem; align-items:center;">
                <span id="pruebas-contador-historico" class="chip chip-large" style="font-weight:600;">
                    0 en hist√≥rico
                </span>
                <span id="pruebas-contador-anual" class="chip chip-large chip-blue" title="Pruebas ANUALES" style="cursor:pointer;">
                    Anual: 0
                </span>
                <span id="pruebas-contador-pt" class="chip chip-large chip-amber" title="Pruebas Post-trabajo" style="cursor:pointer;">
                    Post-trabajo: 0
                </span>
                <span id="pruebas-contador-rep" class="chip chip-large" title="Pruebas de Reparaci√≥n" style="cursor:pointer;">
                    Reparaci√≥n: 0
                </span>
            </div>
        </section>

        <section class="pruebas-dashboard" style="margin-bottom: 1.5rem;">
            <div style="display:flex; align-items:baseline; justify-content:space-between; gap:0.75rem; flex-wrap:wrap; margin-bottom:0.75rem;">
                <h2 style="margin:0;">Resumen de Equipos</h2>
                <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
                    <span id="pruebas-resumen-parcial" style="font-size:0.85rem; color:#6b7280;"></span>
                    <button id="btn-pruebas-completar-resumen" type="button" style="display:none;">Completar resumen</button>
                </div>
            </div>
            <section class="dashboard-cards" style="margin-bottom: 0.75rem;">
                <div class="dash-card">
                    <div class="dash-card-label">Equipos probados 100%</div>
                    <div class="dash-card-value" id="pruebas-equipos-100">0</div>
                    <div style="font-size:0.8rem; color:#4b5563; margin-top:0.25rem; line-height:1.2;">ANUAL + VT/PT/MT + UTT</div>
                </div>
                <div class="dash-card">
                    <div class="dash-card-label">Equipos probados parcialmente</div>
                    <div class="dash-card-value" id="pruebas-equipos-parcial">0</div>
                    <div style="font-size:0.8rem; color:#4b5563; margin-top:0.25rem; line-height:1.2;">Con pruebas, incompleto</div>
                </div>
                <div class="dash-card">
                    <div class="dash-card-label">Equipos sin pruebas</div>
                    <div class="dash-card-value" id="pruebas-equipos-sin">0</div>
                    <div style="font-size:0.8rem; color:#4b5563; margin-top:0.25rem; line-height:1.2;">Sin registros en historial</div>
                    <div style="font-size:0.8rem; color:#6b7280; margin-top:0.15rem; line-height:1.2;">WIP: <strong id="pruebas-equipos-sin-wip">0</strong></div>
                </div>
            </section>
            <div style="font-size:0.85rem; color:#6b7280; margin-top:-0.25rem; margin-bottom:0.75rem;">
                Total equipos base (inventario): <strong id="pruebas-equipos-total">0</strong>
            </div>
            <h2 style="margin:0;">Resumen de estado Pruebas Anuales</h2>

            <section class="dashboard-cards" style="margin-bottom: 0.75rem;">
                <div class="dash-card" style="display:none;">
                    <div class="dash-card-label">Equipos con pruebas vigentes</div>
                    <div class="dash-card-value" id="pruebas-resumen-vigentes">0</div>
                    <div style="font-size:0.8rem; color:#4b5563; margin-top:0.25rem; line-height:1.2;">
                        <div>Por caducar (‚â§60 d√≠as): <strong id="pruebas-resumen-porcaducar">0</strong></div>
                        <div>Caducadas: <strong id="pruebas-resumen-caducadas">0</strong></div>
                    </div>
                </div>
                <div class="dash-card" style="display:none;">
                    <div class="dash-card-label">Equipos con prueba vencida</div>
                    <div class="dash-card-value" id="pruebas-resumen-vencidas">0</div>
                </div>
                <div class="dash-card" style="display:none;">
                    <div class="dash-card-label">Equipos sin prueba registrada</div>
                    <div class="dash-card-value" id="pruebas-resumen-sin">0</div>
                </div>
                <!-- Nueva tabla informativa por categor√≠a de prueba -->
            <section style="margin-bottom: 1rem;">
                <div class="tabla-inspecciones-wrapper" style="overflow-x:auto;">
                    <table id="tabla-informativa" style="width:100%; border-collapse:collapse; font-size:0.9rem; min-width:750px;">
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th style="text-align:left; padding:0.4rem; width:160px;">Tipo de Prueba</th>
                                <th style="text-align:center; padding:0.4rem;">Vigencia &gt; 60 d√≠as</th>
                                <th style="text-align:center; padding:0.4rem;">Vigencia 60-31 d√≠as</th>
                                <th style="text-align:center; padding:0.4rem;">Vigencia 30-16 d√≠as</th>
                                <th style="text-align:center; padding:0.4rem;">Vigencia 15-1 d√≠as</th>
                                <th style="text-align:center; padding:0.4rem;">0 d√≠as (vencidas)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th style="text-align:left; padding:0.4rem; background:#f9fafb;">LT</th>
                                <td id="inf-lt-gt60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-lt-60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-lt-30" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-lt-15" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-lt-0" style="text-align:center; padding:0.4rem;">0</td>
                            </tr>
                            <tr>
                                <th style="text-align:left; padding:0.4rem; background:#f9fafb;">VT/PT/MT</th>
                                <td id="inf-vpm-gt60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-vpm-60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-vpm-30" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-vpm-15" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-vpm-0" style="text-align:center; padding:0.4rem;">0</td>
                            </tr>
                            <tr>
                                <th style="text-align:left; padding:0.4rem; background:#f9fafb;">UTT</th>
                                <td id="inf-utt-gt60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-utt-60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-utt-30" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-utt-15" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-utt-0" style="text-align:center; padding:0.4rem;">0</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>
        </section>

            

            <section id="seccion-resumen-equipo" style="margin-bottom:1rem; display:none;">
                <h3 style="font-size:1rem; margin-bottom:0.35rem;">Estado por equipo (√∫ltima prueba)</h3>
                <p style="font-size:0.85rem; color:#6b7280; margin-bottom:0.5rem;">
                    Para cada equipo se muestra la √∫ltima prueba registrada y su estado de vigencia. Este resumen no se ve afectado por el filtro de b√∫squeda.
                </p>
                <div class="tabla-inspecciones-wrapper" style="overflow-x:auto;">
                    <table id="tabla-pruebas-resumen" style="width:100%; border-collapse:collapse; font-size:0.9rem; min-width:900px;">
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th style="text-align:left; padding:0.4rem;">Equipo</th>
                                <th style="text-align:left; padding:0.4rem;">Descripci√≥n</th>
                                <th style="text-align:left; padding:0.4rem;">√öltima prueba</th>
                                <th style="text-align:left; padding:0.4rem;">Pr√≥xima prueba</th>
                                <th style="text-align:left; padding:0.4rem;">T√©cnico</th>
                                <th style="text-align:left; padding:0.4rem;">No. reporte / cert.</th>
                                <th style="text-align:left; padding:0.4rem;">Estado</th>
                            </tr>
                        </thead>
                        <tbody id="tbody-pruebas-resumen"></tbody>
                    </table>
                    <p id="mensaje-sin-pruebas-resumen" style="font-size:0.9rem; color:#6b7280; margin-top:0.75rem; display:none;">
                        No hay informaci√≥n de pruebas para resumir por equipo.
                    </p>
                </div>
            </section>
        </section>

        <section class="pruebas-panel" style="margin-bottom: 1.5rem;">
            <h2>Pruebas y calibraciones</h2>
            <p style="font-size:0.9rem; color:#6b7280; margin-bottom:0.75rem;">
                Se muestran las pruebas registradas en Firestore y su estado de vigencia seg√∫n la fecha de pr√≥xima prueba.
            </p>

            <section class="actividad-toolbar sticky-list-toolbar" style="margin-bottom: 0.5rem; display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center;">
                <!-- Left: search -->
                <div class="actividad-toolbar-left" style="display:flex; flex-wrap:wrap; gap:0.5rem; align-items:center;">
                    <input type="search" id="pruebas-buscar" placeholder="Buscar por equipo, producto, t√©cnico, reporte..." style="min-width: 260px;">
                </div>
                <!-- Right: actions -->
                <div class="actividad-toolbar-right" style="display:flex; gap:0.5rem; margin-left:auto;">
                    <input id="input-import-csv" type="file" accept=".csv" style="display:none;" />
                    <button id="btn-pruebas-import-csv" title="Importar formato_pruebas.csv" style="display:none;">Ingresar formato.csv</button>
                    <input id="input-delete-csv" type="file" accept=".csv" style="display:none;" />
                    <button id="btn-pruebas-delete-csv" title="Eliminar registros del CSV en Firestore" style="display:none;">Eliminar por CSV</button>
                    <button id="btn-pruebas-refresh" title="Actualizar desde servidor">Actualizar</button>
                    <button id="btn-pruebas-more" title="Cargar m√°s resultados">Cargar m√°s</button>
                    <button id="btn-pruebas-ver-todas" title="Cargar todas las pruebas (bajo demanda)">Ver todas</button>
                    <button id="btn-pruebas-eliminar">Eliminar seleccionadas</button>
                    <button id="btn-pruebas-export-csv">Exportar CSV</button>
                </div>
            </section>

            <!-- Panel de vista previa de importaci√≥n CSV (solo admin) - ubicado bajo el bot√≥n de importar -->
            <section id="import-preview" style="display:none; margin:0.5rem 0 1rem; border:1px solid #e5e7eb; border-radius:8px; padding:0.75rem; background:#fafafa;">
                <h3 style="margin:0 0 0.5rem;">Vista previa de importaci√≥n</h3>
                <div id="import-summary" style="font-size:0.9rem; color:#374151; margin-bottom:0.5rem;"></div>
                <div id="import-warnings" style="font-size:0.85rem; color:#92400e; margin-bottom:0.5rem;"></div>
                <div id="import-errors" style="font-size:0.85rem; color:#991b1b; margin-bottom:0.5rem;"></div>
                <label style="display:flex; gap:0.4rem; align-items:center; font-size:0.85rem; margin:0.25rem 0 0.5rem;">
                    <input type="checkbox" id="chk-import-overwrite">
                    Sobrescribir existentes (actualiza campos si la clave ya existe)
                </label>
                <label style="display:flex; gap:0.4rem; align-items:center; font-size:0.85rem; margin:0 0 0.5rem;">
                    <input type="checkbox" id="chk-auto-import">
                    Auto-importar al validar (modo sobrescribir)
                </label>
                <div id="import-note" style="font-size:0.85rem; color:#b45309; margin-bottom:0.5rem; display:none;">Corrige los errores para continuar.</div>
                <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
                    <label style="display:flex; gap:0.35rem; align-items:center; font-size:0.85rem;">
                        <input type="checkbox" id="chk-use-base" /> Usar base
                    </label>
                    <label style="display:flex; gap:0.35rem; align-items:center; font-size:0.85rem;">
                        Tama√±o base: <input id="input-base-size" type="number" min="1" value="117" style="width:70px;" />
                    </label>
                    <button id="btn-import-confirm" style="display:none;">Confirmar importaci√≥n</button>
                    <button id="btn-import-delete-existing" style="display:none; background:#fee2e2; color:#991b1b;">Eliminar existentes del CSV</button>
                    <button id="btn-import-export-missing" style="display:none;">Exportar faltantes inventario</button>
                    <button id="btn-import-diagnose-missing" style="display:none;">Diagnosticar faltantes vs lista</button>
                    <button id="btn-import-export-errors">Exportar errores CSV</button>
                    <button id="btn-import-show-errors" style="display:none;">Mostrar errores</button>
                    <button id="btn-import-diagnose-existing-only" style="display:none;">Diagnosticar existentes sin CSV</button>
                    <button id="btn-import-summary-sets" style="display:none;">Resumen CSV vs existentes</button>
                    <button id="btn-import-reconcile" style="display:none;">Sugerir reconciliaciones (llave relajada)</button>
                    <button id="btn-import-cancel" style="display:none;">Cancelar</button>
                </div>
            </section>

            <section style="margin-bottom:1rem;">
                <h3 style="font-size:1rem; margin-bottom:0.35rem;">Listado de pruebas</h3>
                <p style="font-size:0.85rem; color:#6b7280; margin-bottom:0.5rem;">
                    Incluye todas las pruebas registradas. Las pruebas con pr√≥xima fecha vencida se resaltan en rojo.
                </p>
                <div class="tabla-inspecciones-wrapper listado-scroll" style="overflow-x:auto;">
                    <table id="tabla-pruebas-listado" style="width:100%; border-collapse:collapse; font-size:0.9rem; min-width:1050px;">
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th style="text-align:left; padding:0.4rem; width:32px;"><input type="checkbox" id="pruebas-select-todos"></th>
                                <th style="text-align:left; padding:0.4rem;">Fecha realizaci√≥n</th>
                                <th style="text-align:left; padding:0.4rem;">Pr√≥xima prueba</th>
                                <th style="text-align:left; padding:0.4rem;">Periodo</th>
                                <th style="text-align:left; padding:0.4rem;">Estado</th>
                                <th style="text-align:left; padding:0.4rem;">D√≠as para pr√≥xima Prueba</th>
                                <th style="text-align:left; padding:0.4rem;">Equipo</th>
                                <th style="text-align:left; padding:0.4rem;">Producto</th>
                                <th style="text-align:left; padding:0.4rem;">Descripci√≥n</th>
                                <th style="text-align:left; padding:0.4rem;">Prueba / Calib.</th>
                                <th style="text-align:left; padding:0.4rem;">√Årea inspecci√≥n</th>
                                <th style="text-align:left; padding:0.4rem;">No. reporte / cert.</th>
                                <th style="text-align:left; padding:0.4rem;">Resultado</th>
                                <th style="text-align:left; padding:0.4rem;">Emisor</th>
                                <th style="text-align:left; padding:0.4rem;">T√©cnico</th>
                            </tr>
                        </thead>
                        <tbody id="tbody-pruebas-listado"></tbody>
                    </table>
                    <p id="mensaje-sin-pruebas-listado" style="font-size:0.9rem; color:#6b7280; margin-top:0.75rem; display:none;">
                        No hay pruebas registradas todav√≠a.
                    </p>
                </div>
                <div id="pruebas-load-more" style="display:flex; gap:0.5rem; justify-content:center; align-items:center; margin-top:0.75rem; flex-wrap:wrap;">
                    <button id="btn-pruebas-more-200" type="button">Ver m√°s 200</button>
                    <button id="btn-pruebas-more-500" type="button">Ver m√°s 500</button>
                    <button id="btn-pruebas-more-all" type="button">Ver todas</button>
                </div>
            </section>
        </section>

        <div id="pl-edit-modal" style="position:fixed; inset:0; background:rgba(0,0,0,0.35); display:none; align-items:center; justify-content:center; z-index:80;">
            <div style="background:white; max-width:720px; width:96%; border-radius:0.75rem; box-shadow:0 10px 40px rgba(15,23,42,0.35); padding:1rem 1.25rem;">
                <div style="display:flex; align-items:center; justify-content:space-between; gap:0.75rem; margin-bottom:0.75rem;">
                    <div>
                        <div style="font-weight:700; font-size:1rem;">Editar fechas</div>
                        <div id="pl-edit-subtitle" style="font-size:0.85rem; color:#6b7280;"></div>
                    </div>
                    <button id="pl-edit-close" type="button">Cerrar</button>
                </div>

                <div style="display:grid; grid-template-columns:1fr 1fr; gap:0.75rem; align-items:end;">
                    <label style="display:flex; flex-direction:column; gap:0.25rem;">
                        <span style="font-size:0.85rem; color:#374151;">Fecha realizaci√≥n (dd/mm/aa)</span>
                        <input id="pl-edit-fecha-real" type="text" inputmode="numeric" placeholder="06/06/25" style="padding:0.5rem; border:1px solid #d1d5db; border-radius:0.5rem;">
                    </label>
                    <label style="display:flex; flex-direction:column; gap:0.25rem;">
                        <span style="font-size:0.85rem; color:#374151;">Pr√≥xima prueba (dd/mm/aa)</span>
                        <input id="pl-edit-proxima" type="text" inputmode="numeric" placeholder="06/06/26" style="padding:0.5rem; border:1px solid #d1d5db; border-radius:0.5rem;">
                    </label>
                </div>

                <div style="display:flex; justify-content:space-between; gap:0.75rem; align-items:center; margin-top:0.75rem; flex-wrap:wrap;">
                    <div id="pl-edit-msg" style="font-size:0.85rem; color:#6b7280;"></div>
                    <div style="display:flex; gap:0.5rem;">
                        <button id="pl-edit-cancel" type="button">Cancelar</button>
                        <button id="pl-edit-save" type="button">Guardar</button>
                    </div>
                </div>
            </div>
        </div>

        </section>
    </main>

    <script src="nav.js"></script>
    <script src="inspector-pruebas-store.js"></script>

    <script src="config.local.js"></script>
    <script type="module" src="firebase-init.js"></script>
    <script type="module">
    import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    const auth = window.auth;
    const APP_VERSION = '2026-02-26-1';

    (async () => {
        try {
            const prev = localStorage.getItem('appVersion_pruebaslist');
            if (prev !== APP_VERSION) {
                localStorage.setItem('appVersion_pruebaslist', APP_VERSION);
                if (window.caches && caches.keys) {
                    try {
                        const keys = await caches.keys();
                        await Promise.all(keys.map(k => caches.delete(k).catch(() => {})));
                    } catch {}
                }
                const url = new URL(window.location.href);
                url.searchParams.set('v', APP_VERSION + '-' + Date.now());
                window.location.replace(url.toString());
                return;
            }
        } catch {}
    })();

    const emailSpan = document.getElementById('nav-user-email');
    const btnLogout = document.getElementById('btn-logout');

    onAuthStateChanged(auth, async (user) => {
        if (!user) {
            window.location.href = 'website.html';
            return;
        }

        // Exportar todos los errores de validaci√≥n a un archivo de texto
        const btnExportErrors = document.getElementById('btn-import-export-errors');
        if (btnExportErrors) {
            btnExportErrors.addEventListener('click', () => {
                try {
                    const res = window.__lastValidationResult;
                    const errs = (res && Array.isArray(res.errors)) ? res.errors : [];
                    if (!errs.length) { alert('No hay errores para exportar.'); return; }
                    const contenido = errs.join('\n');
                    const blob = new Blob([contenido], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'errores_validacion_pruebas.txt';
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
                } catch (e) {
                    alert('No fue posible exportar los errores.');
                }
            });
        }

        // Reconciliaci√≥n por llave relajada: encuentra parejas CSV vs existentes que coinciden relajado pero no estricto
        const btnReconcile = document.getElementById('btn-import-reconcile');
        if (btnReconcile) {
            btnReconcile.addEventListener('click', () => {
                try {
                    if (window.buildExistingKeys) window.buildExistingKeys();
                    const exSetStrict = (window.getExistingKeysSet && window.getExistingKeysSet()) || new Set();
                    // Construir mapas relaxed para existentes
                    const existentesRelax = new Map();
                    (pruebas || []).forEach(reg => {
                        const kR = composeKeyRelaxed({
                            equipo: reg.equipo,
                            numeroSerie: reg.serial || reg.numeroSerie,
                            periodo: reg.periodo,
                            prueba: reg.prueba,
                            fechaRealizacion: reg.fechaRealizacion,
                            noReporte: reg.noReporte,
                            area: reg.area,
                        });
                        if (kR) existentesRelax.set(kR, reg);
                    });
                    // Preparar filas del CSV
                    let rows = (window.getImportRowsReady && window.getImportRowsReady()) || [];
                    if (!rows.length && (window.getLastCsvText && window.getLastCsvText())) {
                        const r = validateCsv(window.getLastCsvText());
                        rows = r.valids || [];
                    }
                    if (!rows.length) { alert('Primero selecciona el CSV para diagnosticar.'); return; }
                    const candidatos = [];
                    rows.forEach(r => {
                        const kStrict = composeKey({
                            equipo: r.equipo,
                            numeroSerie: r.serial,
                            periodo: r.periodo,
                            prueba: r.prueba,
                            fechaRealizacion: r.fechaRealizacion,
                            noReporte: r.noReporte,
                            area: r.area,
                        });
                        const kRelax = composeKeyRelaxed({
                            equipo: r.equipo,
                            numeroSerie: r.serial,
                            periodo: r.periodo,
                            prueba: r.prueba,
                            fechaRealizacion: r.fechaRealizacion,
                            noReporte: r.noReporte,
                            area: r.area,
                        });
                        if (!exSetStrict.has(kStrict) && existentesRelax.has(kRelax)) {
                            const reg = existentesRelax.get(kRelax);
                            candidatos.push({ kStrict, kRelax, noReporteCsv: r.noReporte, noReporteExist: reg && reg.noReporte });
                        }
                    });
                    const cont = document.getElementById('import-errors');
                    if (cont) {
                        if (!candidatos.length) {
                            cont.innerHTML = 'No se encontraron coincidencias por llave relajada. Las diferencias no son solo de puntuaci√≥n en noReporte.';
                        } else {
                            const sample = candidatos.slice(0, 20).map(c => `<li><code>${c.kStrict}</code><br><small>relajado coincide con existente (CSV noReporte: ${c.noReporteCsv} ‚Üí normalizado; existente noReporte: ${c.noReporteExist})</small></li>`).join('');
                            const extra = candidatos.length>20 ? `<div>... y ${candidatos.length-20} m√°s</div>` : '';
                            cont.innerHTML = `<div>Posibles reconciliaciones por llave relajada: <strong>${candidatos.length}</strong></div><ul>${sample}</ul>${extra}`;
                        }
                    } else {
                        alert(`Posibles reconciliaciones por llave relajada: ${candidatos.length}`);
                    }
                } catch (e) {
                    console.error('Reconciliaci√≥n relajada fall√≥', e);
                    alert(`No fue posible sugerir reconciliaciones. Detalle: ${e && (e.message||e.toString())}`);
                }
            });
        }

        // Diagn√≥stico: existentes que no est√°n en CSV
        const btnDiagnoseExistingOnly = document.getElementById('btn-import-diagnose-existing-only');
        if (btnDiagnoseExistingOnly) {
            btnDiagnoseExistingOnly.addEventListener('click', () => {
                try {
                    const keyFn = (window && typeof window.composeKey === 'function')
                        ? window.composeKey
                        : (typeof composeKey === 'function' ? composeKey : null);
                    if (!keyFn) throw new Error('composeKey is not defined');
                    if (window.buildExistingKeys) window.buildExistingKeys();
                    let rows = (window.getImportRowsReady && window.getImportRowsReady()) || [];
                    if (!rows.length && (window.getLastCsvText && window.getLastCsvText())) {
                        const r = validateCsv(window.getLastCsvText());
                        rows = r.valids || [];
                    }
                    if (!rows.length) { alert('Primero selecciona el CSV para diagnosticar.'); return; }
                    const csvKeys = new Set();
                    rows.forEach(r => {
                        const k = keyFn({
                            equipo: r.equipo,
                            numeroSerie: r.serial,
                            periodo: r.periodo,
                            prueba: r.prueba,
                            fechaRealizacion: r.fechaRealizacion,
                            noReporte: r.noReporte,
                            area: r.area,
                        });
                        if (k) csvKeys.add(k);
                    });
                    const exSet = (window.getExistingKeysSet && window.getExistingKeysSet()) || existingKeys || new Set();
                    const onlyExisting = [];
                    exSet.forEach(k => { if (!csvKeys.has(k)) onlyExisting.push(k); });
                    const cont = document.getElementById('import-errors');
                    if (cont) {
                        if (!onlyExisting.length) {
                            cont.innerHTML = 'Todos los existentes tienen correspondencia en el CSV (por llave).';
                        } else {
                            const sample = onlyExisting.slice(0, 15).map(x => `<li>${x}</li>`).join('');
                            cont.innerHTML = `<div>Registros existentes que NO est√°n en el CSV: <strong>${onlyExisting.length}</strong></div><ul>${sample}</ul>` + (onlyExisting.length>15?`<div>... y ${onlyExisting.length-15} m√°s</div>`:'');
                        }
                    } else {
                        alert(`Existentes sin CSV: ${onlyExisting.length}`);
                    }
                } catch (e) {
                    console.error('Diagn√≥stico existentes sin CSV fall√≥', e);
                    alert(`No fue posible ejecutar el diagn√≥stico. Detalle: ${e && (e.message||e.toString())}`);
                }
            });
        }

        // Resumen de conjuntos: CSV vs existentes
        const btnSummarySets = document.getElementById('btn-import-summary-sets');
        if (btnSummarySets) {
            btnSummarySets.addEventListener('click', () => {
                try {
                    const keyFn = (window && typeof window.composeKey === 'function')
                        ? window.composeKey
                        : (typeof composeKey === 'function' ? composeKey : null);
                    if (!keyFn) throw new Error('composeKey is not defined');
                    if (window.buildExistingKeys) window.buildExistingKeys();
                    const exSet = (window.getExistingKeysSet && window.getExistingKeysSet()) || existingKeys || new Set();
                    const existingCount = exSet.size;
                    let rows = (window.getImportRowsReady && window.getImportRowsReady()) || [];
                    if (!rows.length && (window.getLastCsvText && window.getLastCsvText())) {
                        const r = validateCsv(window.getLastCsvText());
                        rows = r.valids || [];
                    }
                    if (!rows.length) { alert('Primero selecciona el CSV para diagnosticar.'); return; }
                    const csvKeys = new Set();
                    const keyFreq = new Map();
                    rows.forEach(r => {
                        const k = keyFn({
                            equipo: r.equipo,
                            numeroSerie: r.serial,
                            periodo: r.periodo,
                            prueba: r.prueba,
                            fechaRealizacion: r.fechaRealizacion,
                            noReporte: r.noReporte,
                            area: r.area,
                        });
                        if (k) {
                            csvKeys.add(k);
                            keyFreq.set(k, (keyFreq.get(k)||0)+1);
                        }
                    });
                    const csvTotalRows = rows.length;
                    const csvCount = csvKeys.size;
                    // ¬øUsar base? base = onlyExisting ‚à™ subset(intersection) hasta tama√±o base
                    const useBase = !!(document.getElementById('chk-use-base') && document.getElementById('chk-use-base').checked);
                    const baseSizeInput = document.getElementById('input-base-size');
                    const baseTarget = Math.max(1, parseInt((baseSizeInput && baseSizeInput.value) ? baseSizeInput.value : '117', 10));

                    let inter = 0;
                    const interList = [];
                    csvKeys.forEach(k => { if (exSet.has(k)) { inter++; interList.push(k); } });
                    const onlyExistingSet = new Set();
                    exSet.forEach(k => { if (!csvKeys.has(k)) onlyExistingSet.add(k); });

                    let onlyCsv, onlyExisting, union, effectiveExistingCount, note = '';
                    if (!useBase) {
                        onlyCsv = csvCount - inter;
                        onlyExisting = existingCount - inter;
                        union = inter + onlyCsv + onlyExisting;
                        effectiveExistingCount = existingCount;
                    } else {
                        // Construir base
                        const baseSet = new Set();
                        // 1) incluir todos los existentes fuera del CSV
                        onlyExistingSet.forEach(k => baseSet.add(k));
                        // 2) completar con parte de la intersecci√≥n hasta baseTarget
                        let need = Math.max(0, baseTarget - baseSet.size);
                        for (let i=0; i<interList.length && need>0; i++) { baseSet.add(interList[i]); need--; }

                        // Recalcular m√©tricas respecto a la base
                        effectiveExistingCount = baseSet.size;
                        let interBase = 0;
                        csvKeys.forEach(k => { if (baseSet.has(k)) interBase++; });
                        inter = interBase;
                        onlyCsv = csvCount - interBase;
                        let onlyBase = 0; baseSet.forEach(k => { if (!csvKeys.has(k)) onlyBase++; });
                        onlyExisting = onlyBase;
                        union = interBase + onlyCsv + onlyBase;
                        note = ` (usando base=${effectiveExistingCount}, objetivo=${baseTarget})`;
                    }

                    // Nota sobre duplicados dentro del CSV (mismas llaves)
                    let dupCount = 0;
                    keyFreq.forEach(v => { if (v>1) dupCount += (v-1); });

                    const sumEl = document.getElementById('import-summary');
                    const nominal = csvTotalRows + effectiveExistingCount; // nominal seg√∫n contexto actual (base o global)
                    const globalNominal = csvTotalRows + existingCount;    // referencia global sin base
                    const volumeLabel = 'Volumen bruto (sin deduplicar)';

                    const summaryStr = useBase
                        ? (
                            `Resumen conjuntos ‚Äî Base + CSV (nominal): <strong>${nominal}</strong>, Base ‚à™ CSV (deduplicada): <strong>${union}</strong>${note} ‚Äî ` +
                            `CSV v√°lidos (filas): <strong>${csvTotalRows}</strong>, CSV llaves √∫nicas: <strong>${csvCount}</strong>, Base: <strong>${effectiveExistingCount}</strong>, Intersecci√≥n: <strong>${inter}</strong>, ` +
                            `Solo CSV: <strong>${onlyCsv}</strong>, Solo base: <strong>${onlyExisting}</strong> ‚Äî ${volumeLabel}: <strong>${globalNominal}</strong>`
                          ) + (dupCount ? ` ‚Äî Duplicados intra-CSV: <strong>${dupCount}</strong>` : '')
                        : (
                            `Resumen conjuntos ‚Äî CSV v√°lidos (filas): <strong>${csvTotalRows}</strong>, CSV llaves √∫nicas: <strong>${csvCount}</strong>, Existentes: <strong>${effectiveExistingCount}</strong>, ` +
                            `Intersecci√≥n: <strong>${inter}</strong>, Solo CSV: <strong>${onlyCsv}</strong>, Solo existentes: <strong>${onlyExisting}</strong>, ` +
                            `Uni√≥n (deduplicada): <strong>${union}</strong>, ${volumeLabel}: <strong>${nominal}</strong>`
                          ) + (dupCount ? ` ‚Äî Duplicados intra-CSV: <strong>${dupCount}</strong>` : '');
                    if (sumEl) {
                        sumEl.innerHTML = summaryStr;
                    } else {
                        alert(summaryStr.replace(/<[^>]+>/g,'') );
                    }
                } catch (e) {
                    console.error('Resumen conjuntos fall√≥', e);
                    alert(`No fue posible calcular el resumen. Detalle: ${e && (e.message||e.toString())}`);
                }
            });
        }

        // (Se calcula tras cargar las pruebas en cargarPruebasDesdeFirestore)

        const email = (user.email || '').toLowerCase();
        if (emailSpan) emailSpan.textContent = email;

        try {
            const idTok = await user.getIdTokenResult();
            const role = (idTok && idTok.claims && idTok.claims.role) || null;
            window.userRole = role;
            window.isAdmin = role === 'admin';
            window.isDirector = role === 'director';
            window.isSupervisor = role === 'supervisor';
            window.isInspector = role === 'inspector';
            window.isCapturista = role === 'capturista';
            window.isAuxger = role === 'auxger';
        } catch {}

        window.currentUserEmail = email;

        // Permisos por rol
        const permitirEliminar = !!(window.isAdmin || window.isDirector || window.isSupervisor);

        // Ajustar encabezado: ocultar columna de selecci√≥n si no se permite eliminar
        try {
            if (!permitirEliminar) {
                const thSel = document.querySelector('#tabla-pruebas-listado thead th:first-child');
                if (thSel) thSel.style.display = 'none';
            }
        } catch {}

        const params = new URLSearchParams(window.location.search || '');
        const localMode = params.get('local') === '1';

        // Inspector: no debe acceder al listado global; usar modo local
        try {
            if (window.isInspector && !localMode) {
                const url = new URL(window.location.href);
                url.searchParams.set('local', '1');
                window.location.replace(url.toString());
                return;
            }
        } catch {}

        // Modo local: no consultar Firestore, renderizar solo desde IndexedDB
        if (localMode) {
            try {
                const dash = document.querySelector('.pruebas-dashboard');
                if (dash) dash.style.display = 'none';
            } catch {}
            try {
                await cargarPruebasLocal();
            } catch (e) {
                console.error('No se pudieron cargar pruebas locales', e);
            }
            return;
        }

        // Ocultar panel de resumen costoso para capturista
        try {
            if (window.isCapturista) {
                const dash = document.querySelector('.pruebas-dashboard');
                if (dash) dash.style.display = 'none';
            }
        } catch {}

        // Todos los roles autenticados pueden ver esta p√°gina; el UI ya se ajusta v√≠a nav.js
        cargarPruebasDesdeFirestore();
    });

    async function cargarPruebasLocal() {
        const tbodyListado = document.getElementById('tbody-pruebas-listado');
        const msgListado = document.getElementById('mensaje-sin-pruebas-listado');
        const loadMore = document.getElementById('pruebas-load-more');
        const buscarWrap = document.getElementById('pruebas-buscar')?.closest('section') || null;

        try { if (loadMore) loadMore.style.display = 'none'; } catch {}
        try { if (buscarWrap) buscarWrap.style.display = 'none'; } catch {}

        if (!tbodyListado) return;

        const store = window.pctInspectorPruebasStore;
        if (!store || !store.listPruebas) {
            if (msgListado) {
                msgListado.style.display = 'block';
                msgListado.textContent = 'No hay almacenamiento local disponible.';
            }
            return;
        }

        try {
            await store.clearExpired({ dayKey: store.todayKey(), ttlMs: 24 * 60 * 60 * 1000 });
        } catch {}

        const items = await store.listPruebas({ dayKey: store.todayKey(), ttlMs: 24 * 60 * 60 * 1000 });

        tbodyListado.innerHTML = '';
        if (!items.length) {
            if (msgListado) {
                msgListado.style.display = 'block';
                msgListado.textContent = 'No hay pruebas locales registradas hoy.';
            }
            return;
        }
        if (msgListado) msgListado.style.display = 'none';

        const fmt = (ms) => {
            try {
                const d = new Date(ms);
                return d.toLocaleString('es-MX');
            } catch {
                return '';
            }
        };

        items.forEach(item => {
            const r = item.registro || {};
            const tr = document.createElement('tr');
            const status = (item.status || 'pending').toString();
            const statusTxt = status === 'synced' ? 'Enviada' : 'Pendiente';

            tr.innerHTML = `
                <td style="padding:0.4rem;">
                    <input type="checkbox" disabled>
                </td>
                <td style="padding:0.4rem;">${String(r.fechaRealizacion || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.proxima || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.periodo || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${statusTxt}</td>
                <td style="padding:0.4rem;">${fmt(item.createdAt)}</td>
                <td style="padding:0.4rem;">${String(r.equipo || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.producto || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.descripcion || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.pruebaTipo || r.prueba || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.area || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.noReporte || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.resultado || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.emisor || '').trim() || ''}</td>
                <td style="padding:0.4rem;">${String(r.tecnico || '').trim() || ''}</td>
            `;
            tbodyListado.appendChild(tr);
        });
    }

    if (btnLogout) {
        btnLogout.addEventListener('click', async () => {
            try {
                await signOut(auth);
            } finally {
                window.location.href = 'website.html';
            }
        });
    }

    async function cargarPruebasDesdeFirestore() {
        const tbodyListado = document.getElementById('tbody-pruebas-listado');
        const msgListado = document.getElementById('mensaje-sin-pruebas-listado');
        const inputBuscar = document.getElementById('pruebas-buscar');
        const lblPend = document.getElementById('pruebas-contador-pendientes');
        const lblVenc = document.getElementById('pruebas-contador-vencidas');
        const lblHist = document.getElementById('pruebas-contador-historico');
        const lblAnual = document.getElementById('pruebas-contador-anual');
        const lblPT = document.getElementById('pruebas-contador-pt');
        const lblRep = document.getElementById('pruebas-contador-rep');
        const btnVerTodas = document.getElementById('btn-pruebas-ver-todas');

        const tbodyResumen = document.getElementById('tbody-pruebas-resumen');
        const msgResumen = document.getElementById('mensaje-sin-pruebas-resumen');
        const lblResVig = document.getElementById('pruebas-resumen-vigentes');
        const lblResVenc = document.getElementById('pruebas-resumen-vencidas');
        const lblResSin = document.getElementById('pruebas-resumen-sin');
        const lblResPorCad = document.getElementById('pruebas-resumen-porcaducar');
        const lblResCaducadas = document.getElementById('pruebas-resumen-caducadas');

        const cardEq100 = document.getElementById('pruebas-equipos-100');
        const cardEqPar = document.getElementById('pruebas-equipos-parcial');
        const cardEqSin = document.getElementById('pruebas-equipos-sin');

        // Celdas de la tabla informativa
        const inf = {
            lt: {
                gt60: document.getElementById('inf-lt-gt60'),
                d60: document.getElementById('inf-lt-60'),
                d30: document.getElementById('inf-lt-30'),
                d15: document.getElementById('inf-lt-15'),
                d0:  document.getElementById('inf-lt-0'),
            },
            vpm: {
                gt60: document.getElementById('inf-vpm-gt60'),
                d60: document.getElementById('inf-vpm-60'),
                d30: document.getElementById('inf-vpm-30'),
                d15: document.getElementById('inf-vpm-15'),
                d0:  document.getElementById('inf-vpm-0'),
            },
            utt: {
                gt60: document.getElementById('inf-utt-gt60'),
                d60: document.getElementById('inf-utt-60'),
                d30: document.getElementById('inf-utt-30'),
                d15: document.getElementById('inf-utt-15'),
                d0:  document.getElementById('inf-utt-0'),
            }
        };

        const lblAlert60 = document.getElementById('pruebas-alert-60');
        const lblAlert30 = document.getElementById('pruebas-alert-30');
        const lblAlert15 = document.getElementById('pruebas-alert-15');

        const lblResumenParcial = document.getElementById('pruebas-resumen-parcial');
        const btnCompletarResumen = document.getElementById('btn-pruebas-completar-resumen');

        let _csvPreviewActive = false;
        let _csvPreviewRows = [];

        // Chips de filtro por rango de d√≠as
        const chipGT60 = document.getElementById('chip-gt60');
        const chip60 = document.getElementById('chip-60');
        const chip30 = document.getElementById('chip-30');
        const chip15 = document.getElementById('chip-15');
        const chip0 = document.getElementById('chip-0');
        let filtroRango = null; // 'gt60' | '60' | '30' | '15' | '0' | null

        // Inspector: ocultar chips/res√∫menes y evitar filtros (solo lista recientes 32h)
        const seccionChipsAlertas = document.getElementById('seccion-chips-alertas');
        const seccionChipsPeriodo = document.getElementById('seccion-chips-periodo');
        const seccionResumenEquipo = document.getElementById('seccion-resumen-equipo');
        if (window.isInspector) {
            if (seccionChipsAlertas) seccionChipsAlertas.style.display = 'none';
            if (seccionChipsPeriodo) seccionChipsPeriodo.style.display = 'none';
            if (seccionResumenEquipo) seccionResumenEquipo.style.display = 'none';
            filtroRango = null;
        }

        // Habilitar persistencia offline si est√° disponible (no falla en multi-tab)
        (async ()=>{
            try {
                // enableIndexedDbPersistence() muestra advertencia de deprecaci√≥n en Firestore 10.x.
                // Se omite para evitar ruido en consola; Firestore seguir√° usando cach√© en memoria.
            } catch {}
        })();

        try { console.debug('cargarPruebasDesdeFirestore: init'); } catch {}

        // Filtro por periodo (ANUAL / POST-TRABAJO / REPARACION)
        let filtroPeriodo = null; // null = todos, 'ANUAL' | 'POST-TRABAJO' | 'REPARACION'

        if (window.isInspector) {
            filtroPeriodo = null;
        }

        // Filtro por cobertura de equipos (para la tabla de resumen por equipo)
        let filtroCobertura = null; // null | '100' | 'parcial' | 'sin'
        function actualizarChipsPeriodoActivos() {
            const activeStyle = (el, color) => {
                if (!el) return;
                if (el.dataset.active === '1') {
                    el.style.boxShadow = `0 0 0 2px ${color} inset`;
                    el.style.fontWeight = '700';
                } else {
                    el.style.boxShadow = '';
                    el.style.fontWeight = '';
                }
            };
            if (lblAnual) activeStyle(lblAnual, '#1d4ed8');
            if (lblPT) activeStyle(lblPT, '#f59e0b');
            if (lblRep) activeStyle(lblRep, '#6b7280');
        }
        function setFiltroPeriodo(nuevo) {
            filtroPeriodo = nuevo;
            if (lblAnual) lblAnual.dataset.active = (nuevo === 'ANUAL') ? '1' : '0';
            if (lblPT) lblPT.dataset.active = (nuevo === 'POST-TRABAJO') ? '1' : '0';
            if (lblRep) lblRep.dataset.active = (nuevo === 'REPARACION') ? '1' : '0';
            actualizarChipsPeriodoActivos();
            render();
        }

        if (lblAnual) {
            lblAnual.style.cursor = 'pointer';
            lblAnual.addEventListener('click', () => {
                setFiltroPeriodo((filtroPeriodo === 'ANUAL') ? null : 'ANUAL');
            });
        }

        

        if (lblPT) {
            lblPT.style.cursor = 'pointer';
            lblPT.addEventListener('click', () => {
                setFiltroPeriodo((filtroPeriodo === 'POST-TRABAJO') ? null : 'POST-TRABAJO');
            });
        }
        if (lblRep) {
            lblRep.style.cursor = 'pointer';
            lblRep.addEventListener('click', () => {
                setFiltroPeriodo((filtroPeriodo === 'REPARACION') ? null : 'REPARACION');
            });
        }

        function setFiltroCobertura(nuevo) {
            filtroCobertura = nuevo;
            try {
                const n100 = cardEq100 ? cardEq100.closest('.dash-card') : null;
                const npar = cardEqPar ? cardEqPar.closest('.dash-card') : null;
                const nsin = cardEqSin ? cardEqSin.closest('.dash-card') : null;
                const setActive = (node, active) => {
                    if (!node) return;
                    node.style.boxShadow = active ? '0 0 0 2px #2563eb inset' : '';
                    node.style.fontWeight = active ? '700' : '';
                    node.style.cursor = 'pointer';
                };
                setActive(n100, nuevo === '100');
                setActive(npar, nuevo === 'parcial');
                setActive(nsin, nuevo === 'sin');
            } catch {}
            render();
        }

        try {
            const n100 = cardEq100 ? cardEq100.closest('.dash-card') : null;
            const npar = cardEqPar ? cardEqPar.closest('.dash-card') : null;
            const nsin = cardEqSin ? cardEqSin.closest('.dash-card') : null;
            if (n100) n100.addEventListener('click', () => setFiltroCobertura((filtroCobertura === '100') ? null : '100'));
            if (npar) npar.addEventListener('click', () => setFiltroCobertura((filtroCobertura === 'parcial') ? null : 'parcial'));
            if (nsin) nsin.addEventListener('click', () => setFiltroCobertura((filtroCobertura === 'sin') ? null : 'sin'));
        } catch {}

        const detallePanel = document.getElementById('detalle-prueba');
        const detalleContenido = document.getElementById('detalle-prueba-contenido');

        const chkSelectTodos = document.getElementById('pruebas-select-todos');
        const btnEliminar = document.getElementById('btn-pruebas-eliminar');
        const btnExportCsv = document.getElementById('btn-pruebas-export-csv');
        const btnRefresh = document.getElementById('btn-pruebas-refresh');
        const btnMore = document.getElementById('btn-pruebas-more');
        const btnMore200Bottom = document.getElementById('btn-pruebas-more-200');
        const btnMore500Bottom = document.getElementById('btn-pruebas-more-500');
        const btnMoreAllBottom = document.getElementById('btn-pruebas-more-all');
        const bottomLoadWrap = document.getElementById('pruebas-load-more');
        const btnImportCsv = document.getElementById('btn-pruebas-import-csv');
        const inputImportCsv = document.getElementById('input-import-csv');
        const btnDeleteCsv = document.getElementById('btn-pruebas-delete-csv');
        const inputDeleteCsv = document.getElementById('input-delete-csv');
        const importPreview = document.getElementById('import-preview');
        const importSummary = document.getElementById('import-summary');
        const importWarnings = document.getElementById('import-warnings');
        const importErrors = document.getElementById('import-errors');
        const btnImportConfirm = document.getElementById('btn-import-confirm');
        const btnImportDeleteExisting = document.getElementById('btn-import-delete-existing');
        const btnImportCancel = document.getElementById('btn-import-cancel');

        const permitirEliminar = !!(window.isAdmin || window.isDirector);
        // Ocultar bot√≥n eliminar y cabecera de checkbox si no tiene permiso
        if (btnEliminar) btnEliminar.style.display = permitirEliminar ? '' : 'none';
        if (chkSelectTodos && chkSelectTodos.closest && chkSelectTodos.closest('th')) {
            chkSelectTodos.closest('th').style.display = permitirEliminar ? '' : 'none';
        }

        // Import CSV para admin o director
        if (btnImportCsv) btnImportCsv.style.display = ((window.isAdmin || window.isDirector || window.isAuxger) ? '' : 'none');
        if (btnDeleteCsv) {
            const canDelCsv = (window.isAdmin || window.isDirector);
            if (canDelCsv) {
                try {
                    btnDeleteCsv.style.display = 'inline-block';
                    btnDeleteCsv.style.removeProperty('display');
                    setTimeout(() => { try { btnDeleteCsv.style.display = 'inline-block'; } catch {} }, 0);
                } catch {}
            } else {
                btnDeleteCsv.style.display = 'none';
            }
            try { console.debug('roles:', { isAdmin: window.isAdmin, isDirector: window.isDirector }, 'btnDeleteCsv visible:', canDelCsv); } catch {}
        }
        if (btnImportConfirm) btnImportConfirm.style.display = 'none';
        if (btnImportDeleteExisting) btnImportDeleteExisting.style.display = 'none';
        if (btnImportCancel) btnImportCancel.style.display = 'none';

        // Guard de navegaci√≥n durante procesos largos (import/delete)
        let _unloadHandler = null;
        function setProcessingGuard(active) {
            try {
                if (active) {
                    if (_unloadHandler) return;
                    _unloadHandler = (e) => { e.preventDefault(); e.returnValue = 'Hay un proceso en curso. No cierres ni recargues la p√°gina.'; };
                    window.addEventListener('beforeunload', _unloadHandler);
                } else {
                    if (_unloadHandler) {
                        window.removeEventListener('beforeunload', _unloadHandler);
                        _unloadHandler = null;
                    }
                }
            } catch {}
        }

        // Eliminar por CSV: flujo independiente que no activa auto-import (ubicado tras inicializaci√≥n de variables)
        if (btnDeleteCsv && inputDeleteCsv) {
            btnDeleteCsv.addEventListener('click', () => inputDeleteCsv.click());
            inputDeleteCsv.addEventListener('change', async (ev) => {
                if (!(window.isAdmin || window.isDirector)) { alert('Se requiere rol admin o director para eliminar por CSV.'); return; }
                const file = ev.target.files && ev.target.files[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    const res = validateCsv(text);
                    const rowsToDelete = res.valids || [];
                    if (!rowsToDelete.length) { alert('El CSV no contiene filas v√°lidas para eliminar.'); return; }
                    const okGo = window.confirm('Se iniciar√° la ELIMINACI√ìN de los registros del CSV. Este proceso no tiene vuelta atr√°s y no debes cerrar ni recargar la p√°gina hasta que termine. ¬øDeseas continuar?');
                    if (!okGo) return;
                    if (importPreview) importPreview.style.display = '';
                    if (importWarnings) importWarnings.innerHTML = '';
                    if (importErrors) importErrors.innerHTML = '';
                    if (importSummary) importSummary.innerHTML = `Eliminando... <strong>0</strong> / ${rowsToDelete.length}`;
                    setProcessingGuard(true);
                    const delRes = await deleteExistingFromCsv(rowsToDelete);
                    if (importSummary) importSummary.innerHTML = `Eliminados: <strong>${delRes.delOk}</strong>, No encontrados: ${delRes.delMiss}, Fallidos: ${delRes.delFail}`;
                    // Recargar listado
                    const desdeFs2 = await leerFirestore();
                    if (desdeFs2 && Array.isArray(desdeFs2)) pruebas = desdeFs2;
                    buildExistingKeys();
                    render();
                } catch (e) {
                    alert('No se pudo procesar el CSV para eliminar.');
                } finally {
                    if (inputDeleteCsv) inputDeleteCsv.value = '';
                    setProcessingGuard(false);
                }
            });
        }

        // Fijar listener de eliminaci√≥n tan pronto como el bot√≥n exista
        if (btnImportDeleteExisting) {
            btnImportDeleteExisting.addEventListener('click', async () => {
                if (!importRowsReady || !importRowsReady.length) { alert('No hay filas para procesar.'); return; }
                if (!(window.isAdmin || window.isDirector)) { alert('Se requiere rol admin o director para eliminar.'); return; }
                btnImportDeleteExisting.disabled = true;
                try {
                    const res = await deleteExistingFromCsv(importRowsReady||[]);
                    importSummary.innerHTML += ` ‚Äî Eliminados: <strong>${res.delOk}</strong>, No encontrados: ${res.delMiss}, Fallidos: ${res.delFail}`;
                    const desdeFs2 = await leerFirestore();
                    if (desdeFs2 && Array.isArray(desdeFs2)) pruebas = desdeFs2;
                    buildExistingKeys();
                    render();
                } finally {
                    btnImportDeleteExisting.disabled = false;
                }
            });
        }

        // Id (o clave) de la prueba actualmente seleccionada en el panel de detalle
        let pruebaSeleccionadaId = null;

        if (!tbodyListado) { /* continuar para permitir acciones de importaci√≥n */ }

        // Botones de control de carga para limitar lecturas
        if (btnRefresh) {
            btnRefresh.addEventListener('click', async () => {
                await leerPagina({ reset: true, forceNetwork: true });
                render();
            });
        }
        if (btnMore) {
            btnMore.addEventListener('click', async () => {
                await leerPagina({ reset: false, forceNetwork: false });
                render();
            });
        }

        try {
            if (auth && auth.currentUser) {
                await auth.currentUser.getIdToken(true);
            }
        } catch {}

        let pruebas = [];
        let _lastDoc = null;
        const _pageLimit = 200;
        const claveLocal = 'pct_pruebas';
        let _totalServer = null;
        let _isLoadingAll = false;
        let _isLoadingMore = false;

        let _paginationMode = 'creadoEn';
        let _loadedIds = new Set();

        // Exponer dataset para diagn√≥stico en consola
        try {
            window.pctGetPruebas = () => (Array.isArray(pruebas) ? pruebas : []);
            window.pruebas = window.pctGetPruebas();
        } catch {}

        // Inventario base desde invre.csv/invre2.csv para mostrar todos los equipos, incluso sin pruebas.
        let equiposInventario = new Set();
        let descripcionPorEquipoInv = {};
        let productoPorEquipoInv = {};
        let descripcionPorSerialInv = {};
        let productoPorSerialInv = {};
        let serialPorEquipoInv = {};
        let edoPorEquipoInv = {};
        // √Åreas por equipo/serial y tipo de prueba (derivadas de invre2.csv)
        let areaPorEquipoPruebaInv = {};
        let areaPorSerialPruebaInv = {};

        async function leerFirestore() {
            try {
                const { getFirestore, collection, getDocs } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );

                const db = getFirestore();
                const colRef = collection(db, 'pruebas');
                const snap = await getDocs(colRef);
                return snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (e) {
                console.error('Error al leer pruebas desde Firestore, se usar√° localStorage como respaldo', e);
                return null;
            }
        }

        async function leerTotalServidor() {
            try {
                // Si ya hay un total cacheado, usarlo y NO disparar agregaci√≥n.
                // Esto evita el spam de 429 (RunAggregationQuery) en consola.
                try {
                    const cachedNow = Number(localStorage.getItem('pct_pruebas_total_cached') || '0');
                    if (cachedNow && !isNaN(cachedNow) && cachedNow > 0) {
                        _totalServer = cachedNow;
                        return;
                    }
                } catch {}

                // Cooldown para evitar 429 por agregaci√≥n (getCountFromServer) en Firestore.
                // Si se excede cuota, esperamos un tiempo antes de reintentar.
                try {
                    const until = Number(localStorage.getItem('pct_pruebas_count_cooldown_until') || '0');
                    if (until && !isNaN(until) && Date.now() < until) {
                        const cached = Number(localStorage.getItem('pct_pruebas_total_cached') || '0');
                        _totalServer = (cached && !isNaN(cached) && cached > 0) ? cached : null;
                        if (_totalServer == null) {
                            try {
                                const { getFirestore, collection, getDocsFromCache } = await import(
                                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                                );
                                const db = getFirestore();
                                const colRef = collection(db, 'pruebas');
                                const snapCacheOnly = await getDocsFromCache(colRef);
                                const approx = snapCacheOnly.size;
                                if (typeof approx === 'number' && isFinite(approx) && approx > 0) {
                                    _totalServer = approx;
                                    try { localStorage.setItem('pct_pruebas_total_cached', String(approx)); } catch {}
                                }
                            } catch {}
                        }
                        return;
                    }
                } catch {}
                const { getFirestore, collection, getCountFromServer } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = getFirestore();
                const colRef = collection(db, 'pruebas');
                const agg = await getCountFromServer(colRef);
                _totalServer = agg.data().count;
                try {
                    if (typeof _totalServer === 'number' && isFinite(_totalServer) && _totalServer > 0) {
                        localStorage.setItem('pct_pruebas_total_cached', String(_totalServer));
                    }
                } catch {}
            } catch (e) {
                const cached = (() => {
                    try {
                        const v = Number(localStorage.getItem('pct_pruebas_total_cached') || '0');
                        return (v && !isNaN(v) && v > 0) ? v : null;
                    } catch { return null; }
                })();
                _totalServer = cached;
                const code = (e && (e.code || (e.name && String(e.name)))) ? String(e.code || e.name) : '';
                const msg = (e && e.message) ? String(e.message) : '';
                const is429 = code.includes('resource-exhausted') || /429/.test(msg) || /Too Many Requests/i.test(msg);
                if (is429) {
                    try {
                        const minutes = 15;
                        localStorage.setItem('pct_pruebas_count_cooldown_until', String(Date.now() + minutes * 60 * 1000));
                    } catch {}
                    console.warn('Firestore rate limit: se omite conteo total temporalmente (cooldown).');
                }

                // Si no tenemos cached total, intentar obtener un aproximado desde cach√© local (sin agregaci√≥n).
                if (_totalServer == null) {
                    try {
                        const { getFirestore, collection, getDocsFromCache } = await import(
                            'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                        );
                        const db = getFirestore();
                        const colRef = collection(db, 'pruebas');
                        const snapCacheOnly = await getDocsFromCache(colRef);
                        const approx = snapCacheOnly.size;
                        if (typeof approx === 'number' && isFinite(approx) && approx > 0) {
                            _totalServer = approx;
                            try { localStorage.setItem('pct_pruebas_total_cached', String(approx)); } catch {}
                        }
                    } catch {}
                }
            }
        }

        // Lectura paginada (orden por creadoEn desc). Cache primero; red solo bajo demanda.
        async function leerPagina({ reset = false, forceNetwork = false } = {}) {
            try {
                const { getFirestore, collection, getDocs, getDocsFromCache, query, orderBy, limit, startAfter, documentId, where } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = getFirestore();
                const colRef = collection(db, 'pruebas');

                if (reset) {
                    _lastDoc = null;
                    pruebas = [];
                    _paginationMode = 'creadoEn';
                    _loadedIds = new Set();
                    try { window.pruebas = window.pctGetPruebas(); } catch {}
                }

                const isInspector = !!window.isInspector;
                const cutoffDate = isInspector ? new Date(Date.now() - (32 * 60 * 60 * 1000)) : null;

                let qBase;
                if (isInspector) {
                    // Inspector: limitar a √∫ltimas 32 horas para reducir lecturas y volumen.
                    qBase = query(colRef, where('creadoEn', '>=', cutoffDate), orderBy('creadoEn', 'desc'), limit(_pageLimit));
                    if (_lastDoc) qBase = query(colRef, where('creadoEn', '>=', cutoffDate), orderBy('creadoEn', 'desc'), startAfter(_lastDoc), limit(_pageLimit));
                } else if (_paginationMode === 'docId') {
                    qBase = query(colRef, orderBy(documentId()), limit(_pageLimit));
                    if (_lastDoc) qBase = query(colRef, orderBy(documentId()), startAfter(_lastDoc), limit(_pageLimit));
                } else {
                    qBase = query(colRef, orderBy('creadoEn', 'desc'), limit(_pageLimit));
                    if (_lastDoc) qBase = query(colRef, orderBy('creadoEn', 'desc'), startAfter(_lastDoc), limit(_pageLimit));
                }

                let snap = null;
                let cacheErr = null;
                let netErr = null;
                if (!forceNetwork) {
                    try { snap = await getDocsFromCache(qBase); }
                    catch (e) { cacheErr = e; }
                }
                if (!snap || snap.empty) {
                    try { snap = await getDocs(qBase); }
                    catch (e) { netErr = e; }
                }
                if (!snap || snap.empty) {
                    // Para inspector no hacemos fallback a docId (evitar recorrer toda la colecci√≥n)
                    if (!isInspector) {
                        // Fallback: hay datasets antiguos sin "creadoEn" o casos donde la ordenaci√≥n no regresa docs.
                        // Usar una paginaci√≥n estable por documentId para poder recorrer TODA la colecci√≥n.
                        try {
                            _paginationMode = 'docId';
                            const qFallback = _lastDoc
                                ? query(colRef, orderBy(documentId()), startAfter(_lastDoc), limit(_pageLimit))
                                : query(colRef, orderBy(documentId()), limit(_pageLimit));
                            snap = forceNetwork ? await getDocs(qFallback) : (await getDocsFromCache(qFallback).catch(() => null)) || (await getDocs(qFallback));
                        } catch {}
                    }
                }

                if (!snap || snap.empty) {
                    if (cacheErr || netErr) {
                        console.error('No se pudo cargar la p√°gina de pruebas (cache/network)', { cacheErr, netErr });
                    }
                    try {
                        const msgListado = document.getElementById('mensaje-sin-pruebas-listado');
                        if (msgListado) {
                            msgListado.style.display = 'block';
                            msgListado.textContent = 'No se pudieron cargar datos de Firestore. Verifica tu sesi√≥n/permisos o intenta "Actualizar".';
                        }
                    } catch {}
                    return 0;
                }

                const nuevos = snap.docs
                    .filter(d => {
                        const id = d && d.id ? String(d.id) : '';
                        if (!id) return false;
                        if (_loadedIds.has(id)) return false;
                        _loadedIds.add(id);
                        return true;
                    })
                    .map(d => ({ id: d.id, ...d.data() }));
                try { console.debug('Pruebas: p√°gina cargada', { count: nuevos.length, reset, forceNetwork }); } catch {}
                pruebas = pruebas.concat(nuevos);
                _lastDoc = snap.docs[snap.docs.length - 1];
                try { localStorage.setItem(claveLocal, JSON.stringify(pruebas)); } catch {}
                try { window.pruebas = window.pctGetPruebas(); } catch {}
                return nuevos.length;
            } catch (e) {
                console.error('Error al leer p√°gina de pruebas', e);
                // Fallback a cache local completa solo en reset
                if (reset) {
                    try {
                        const crudo = JSON.parse(localStorage.getItem(claveLocal) || '[]');
                        if (Array.isArray(crudo)) pruebas = crudo;
                    } catch { pruebas = []; }
                    try { window.pruebas = window.pctGetPruebas(); } catch {}
                }
                return 0;
            }
        }

        // Cargar primera p√°gina: primero cache, luego red si est√° vac√≠o.
        try {
            await leerPagina({ reset: true, forceNetwork: false });
            if (!pruebas || !pruebas.length) {
                await leerPagina({ reset: true, forceNetwork: true });
            }
        } catch (e) {
            console.error('Fallo al cargar pruebas (inicio)', e);
        }

        // Leer total real desde servidor (para mostrar "Mostrando X de Y")
        await leerTotalServidor();

        // Reconstruir llaves tras carga inicial
        try { buildExistingKeys(); } catch {}

        // Render inicial
        try { render(); } catch {}
        try { window.pruebas = window.pctGetPruebas(); } catch {}

        // Auto-completar el resumen al entrar (carga completa en segundo plano)
        try {
            setTimeout(async () => {
                if (_csvPreviewActive) return;
                if (_isLoadingAll || _isLoadingMore) return;
                if (!_lastDoc) {
                    try {
                        if (Array.isArray(pruebas) && pruebas.length) {
                            localStorage.setItem('pct_pruebas_total_cached', String(pruebas.length));
                            _totalServer = pruebas.length;
                        }
                    } catch {}
                    return;
                }

                _isLoadingAll = true;
                try {
                    if (lblResumenParcial) lblResumenParcial.textContent = `Cargando resumen completo...`;
                    let safety = 0;
                    while (_lastDoc && safety < 300) {
                        safety += 1;
                        const added = await leerPagina({ reset: false, forceNetwork: false });
                        if (!added) {
                            const addedNet = await leerPagina({ reset: false, forceNetwork: true });
                            if (!addedNet) break;
                        }
                        if (safety % 3 === 0) {
                            try { buildExistingKeys(); } catch {}
                            try { actualizarContadoresTiposLocal(pruebas); } catch {}
                            render();
                        }
                    }
                } finally {
                    _isLoadingAll = false;
                    try {
                        if (Array.isArray(pruebas) && pruebas.length) {
                            localStorage.setItem('pct_pruebas_total_cached', String(pruebas.length));
                            _totalServer = pruebas.length;
                        }
                    } catch {}
                    try { window.pruebas = window.pctGetPruebas(); } catch {}
                    try { buildExistingKeys(); } catch {}
                    try { actualizarContadoresTiposLocal(pruebas); } catch {}
                    try { render(); } catch {}
                }
            }, 50);
        } catch {}

        async function cargarTodas() {
            if (_isLoadingAll) return;
            if (_totalServer == null) {
                alert('No se pudo obtener el total del servidor. Intenta de nuevo.');
                return;
            }
            const faltan = Math.max(0, _totalServer - (pruebas?.length || 0));
            if (!faltan) return;
            const okGo = window.confirm(`Esto cargar√° todas las pruebas (${_totalServer}). Faltan ${faltan}. Puede tardar y consumir cuota. ¬øDeseas continuar?`);
            if (!okGo) return;

            _isLoadingAll = true;
            try {
                if (btnVerTodas) btnVerTodas.disabled = true;
                while (_lastDoc && (pruebas.length < _totalServer)) {
                    await leerPagina({ reset: false, forceNetwork: true });
                    render();
                }
            } finally {
                _isLoadingAll = false;
                if (btnVerTodas) btnVerTodas.disabled = false;
                // Si ya cargamos todo, fijar cache total para que en el siguiente reload no dependa de aggregation (429)
                try {
                    if (Array.isArray(pruebas) && pruebas.length) {
                        localStorage.setItem('pct_pruebas_total_cached', String(pruebas.length));
                        _totalServer = pruebas.length;
                        try { actualizarContadoresTiposLocal(pruebas); } catch {}
                    }
                } catch {}
            }
        }

        if (btnVerTodas) {
            btnVerTodas.addEventListener('click', async () => {
                await cargarTodas();
            });
        }

        if (btnCompletarResumen) {
            btnCompletarResumen.addEventListener('click', async () => {
                await cargarTodas();
            });
        }

        async function cargarMasCantidad(target) {
            if (_isLoadingAll || _isLoadingMore) return;
            if (!_lastDoc) return;
            const prevLen = pruebas.length;
            _isLoadingMore = true;
            try {
                if (btnMore200Bottom) btnMore200Bottom.disabled = true;
                if (btnMore500Bottom) btnMore500Bottom.disabled = true;
                if (btnMoreAllBottom) btnMoreAllBottom.disabled = true;
                const maxIters = Math.max(1, Math.ceil((target || 200) / 200));
                for (let i = 0; i < maxIters; i++) {
                    if (!_lastDoc) break;
                    await leerPagina({ reset: false, forceNetwork: false });
                    if (_totalServer != null && pruebas.length >= _totalServer) break;
                    if (pruebas.length - prevLen >= target) break;
                }
            } finally {
                _isLoadingMore = false;
                // Si se cargaron m√°s registros que el total cacheado, elevar el total para evitar X>N
                try {
                    const loaded = Array.isArray(pruebas) ? pruebas.length : 0;
                    if (loaded && (typeof _totalServer !== 'number' || _totalServer < loaded)) {
                        _totalServer = loaded;
                        try { localStorage.setItem('pct_pruebas_total_cached', String(loaded)); } catch {}
                    }
                } catch {}
                try { actualizarContadoresTiposLocal(pruebas); } catch {}
                render();
                if (btnMore200Bottom) btnMore200Bottom.disabled = false;
                if (btnMore500Bottom) btnMore500Bottom.disabled = false;
                if (btnMoreAllBottom) btnMoreAllBottom.disabled = false;
            }
        }

        if (btnMore200Bottom) {
            btnMore200Bottom.addEventListener('click', async () => {
                await cargarMasCantidad(200);
            });
        }
        if (btnMore500Bottom) {
            btnMore500Bottom.addEventListener('click', async () => {
                await cargarMasCantidad(500);
            });
        }
        if (btnMoreAllBottom) {
            btnMoreAllBottom.addEventListener('click', async () => {
                await cargarTodas();
            });
        }

        // Actualizar contadores de tipos (Anual, Post-trabajo, Reparaci√≥n) con base en TODAS las pruebas (sin filtros)
        function actualizarContadoresTiposLocal(list) {
            const arr = Array.isArray(list) ? list : [];
            let cAnual = 0, cPT = 0, cRep = 0;
            arr.forEach(reg => {
                const p = (reg.periodo || '').toString().trim().toUpperCase();
                if (p === 'POST-TRABAJO') cPT += 1;
                else if (p === 'REPARACION') cRep += 1;
                else cAnual += 1; // incluye vac√≠o como ANUAL (compat)
            });
            if (lblAnual) lblAnual.textContent = `Anual: ${cAnual}`;
            if (lblPT) lblPT.textContent = `Post-trabajo: ${cPT}`;
            if (lblRep) lblRep.textContent = `Reparaci√≥n: ${cRep}`;
        }
        actualizarContadoresTiposLocal(pruebas);

        function aplicarConteosDesdeCsvPreview(rows) {
            const arr = Array.isArray(rows) ? rows : [];
            _csvPreviewActive = true;
            _csvPreviewRows = arr;

            actualizarContadoresTiposLocal(arr);

            const hoy = hoySinHora();
            let cntPend = 0;
            let cntVenc = 0;
            const totalHistorico = arr.length;

            // Contadores por tipo y bucket (mismos buckets del Resumen de estado)
            const cont = {
                lt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                vpm: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                utt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
            };

            function categoriaPruebaPreview(reg) {
                const p = ((reg.prueba || reg.pruebaTipo || '') + '').toUpperCase();
                if (!p) return null;
                if (p.includes('UTT')) return 'utt';
                if (p.includes('LT')) return 'lt';
                if (p.includes('VT') || p.includes('PT') || p.includes('MT')) return 'vpm';
                return null;
            }

            const anualPorEquipo = new Map();
            arr.forEach(reg => {
                const eq = (reg.equipo || '').toString();
                if (!eq) return;
                const periodo = (reg.periodo || '').toString().trim().toUpperCase();
                if (periodo && periodo !== 'ANUAL') return;
                const fr = parseFechaRealizacion(reg.fechaRealizacion || '') || hoySinHora();
                const actual = anualPorEquipo.get(eq);
                if (!actual || fr.getTime() > actual._fechaRealDate.getTime()) {
                    anualPorEquipo.set(eq, { ...reg, _fechaRealDate: fr, _clasif: clasificarPrueba(reg) });
                }
            });

            // Contadores tipo dashboard
            arr.forEach(reg => {
                const periodoReg = (reg.periodo || '').toString().trim().toUpperCase();
                const esAnualReg = (periodoReg === 'ANUAL' || !periodoReg);
                if (!esAnualReg) return;
                const clasif = clasificarPrueba(reg);
                const estado = clasif ? clasif.estado : 'SIN_FECHA';
                if (estado === 'VENCIDA') { cntVenc += 1; return; }
                if (estado !== 'VIGENTE') return;
                const prox = (clasif && clasif.proxima) ? clasif.proxima : null;
                if (!prox) return;
                const diasNum = Math.round((prox.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
                if (!isNaN(diasNum) && diasNum >= 0 && diasNum <= 60) cntPend += 1;
            });

            // Chips superiores por rango (mismos criterios que render(): solo ANUAL)
            let cntChipGT60 = 0;
            let cntChip60 = 0;
            let cntChip30 = 0;
            let cntChip15 = 0;
            let cntChip0 = 0;
            arr.forEach(reg => {
                const periodoReg = (reg.periodo || '').toString().trim().toUpperCase();
                const esAnualReg = (periodoReg === 'ANUAL' || !periodoReg);
                if (!esAnualReg) return;
                const clasif = clasificarPrueba(reg);
                const estado = clasif ? clasif.estado : 'SIN_FECHA';
                if (estado === 'VENCIDA') { cntChip0 += 1; return; }
                if (estado !== 'VIGENTE') return;
                const prox = (clasif && clasif.proxima) ? clasif.proxima : null;
                if (!prox) return;
                const diasNum = Math.round((prox.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
                if (isNaN(diasNum)) return;
                if (diasNum > 60) cntChipGT60 += 1;
                else if (diasNum >= 31 && diasNum <= 60) cntChip60 += 1;
                else if (diasNum >= 16 && diasNum <= 30) cntChip30 += 1;
                else if (diasNum >= 1 && diasNum <= 15) cntChip15 += 1;
            });

            try {
                const lblAlertGT60 = document.getElementById('pruebas-alert-gt60');
                const lblAlert0 = document.getElementById('pruebas-alert-0');
                if (lblAlertGT60) lblAlertGT60.textContent = String(cntChipGT60);
                if (lblAlert60)   lblAlert60.textContent   = String(cntChip60);
                if (lblAlert30)   lblAlert30.textContent   = String(cntChip30);
                if (lblAlert15)   lblAlert15.textContent   = String(cntChip15);
                if (lblAlert0)    lblAlert0.textContent    = String(cntChip0);
            } catch {}

            // Pintar tabla informativa (Resumen de estado) para ANUAL
            arr.forEach(reg => {
                const periodoReg = (reg.periodo || '').toString().trim().toUpperCase();
                const esAnualReg = (periodoReg === 'ANUAL' || !periodoReg);
                if (!esAnualReg) return;
                const cat = categoriaPruebaPreview(reg);
                if (!cat) return;
                const clasif = clasificarPrueba(reg);
                const prox = (clasif && clasif.proxima) ? clasif.proxima : null;
                if (!prox) return;
                const dias = Math.round((prox.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
                if (isNaN(dias)) return;
                if (dias <= 0) { cont[cat].d0 += 1; return; }
                if (dias > 60) cont[cat].gt60 += 1;
                else if (dias >= 31) cont[cat].d60 += 1;
                else if (dias >= 16) cont[cat].d30 += 1;
                else if (dias >= 1) cont[cat].d15 += 1;
            });

            try {
                if (inf.lt.gt60) inf.lt.gt60.textContent = String(cont.lt.gt60);
                if (inf.lt.d60)  inf.lt.d60.textContent  = String(cont.lt.d60);
                if (inf.lt.d30)  inf.lt.d30.textContent  = String(cont.lt.d30);
                if (inf.lt.d15)  inf.lt.d15.textContent  = String(cont.lt.d15);
                if (inf.lt.d0)   inf.lt.d0.textContent   = String(cont.lt.d0);

                if (inf.vpm.gt60) inf.vpm.gt60.textContent = String(cont.vpm.gt60);
                if (inf.vpm.d60)  inf.vpm.d60.textContent  = String(cont.vpm.d60);
                if (inf.vpm.d30)  inf.vpm.d30.textContent  = String(cont.vpm.d30);
                if (inf.vpm.d15)  inf.vpm.d15.textContent  = String(cont.vpm.d15);
                if (inf.vpm.d0)   inf.vpm.d0.textContent   = String(cont.vpm.d0);

                if (inf.utt.gt60) inf.utt.gt60.textContent = String(cont.utt.gt60);
                if (inf.utt.d60)  inf.utt.d60.textContent  = String(cont.utt.d60);
                if (inf.utt.d30)  inf.utt.d30.textContent  = String(cont.utt.d30);
                if (inf.utt.d15)  inf.utt.d15.textContent  = String(cont.utt.d15);
                if (inf.utt.d0)   inf.utt.d0.textContent   = String(cont.utt.d0);
            } catch {}

            if (lblPend) lblPend.textContent = `${cntPend} por realizar`;
            if (lblVenc) lblVenc.textContent = `${cntVenc} vencida${cntVenc === 1 ? '' : 's'}`;
            if (lblHist) lblHist.textContent = `${totalHistorico} en hist√≥rico`;

            if (lblResumenParcial) lblResumenParcial.textContent = `Resumen basado en CSV (${totalHistorico})`;
            if (btnCompletarResumen) btnCompletarResumen.style.display = 'none';

            // Resumen por equipo basado solo en CSV (equipos presentes)
            try {
                if (lblResVig && lblResVenc && lblResSin) {
                    const equipos = Array.from(anualPorEquipo.keys());
                    let cntEquiposVig = 0;
                    let cntEquiposVenc = 0;
                    let cntEquiposSin = 0;
                    let cntEquiposPorCaducar = 0;
                    equipos.forEach(eq => {
                        const reg = anualPorEquipo.get(eq) || null;
                        const estado = reg ? (reg._clasif && reg._clasif.estado ? reg._clasif.estado : 'SIN_FECHA') : 'SIN_PRUEBA';
                        if (estado === 'VIGENTE') {
                            cntEquiposVig += 1;
                            const dProx = parseProxima(reg ? (reg.proxima || '') : '');
                            if (dProx) {
                                const dias = Math.round((dProx.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
                                if (dias >= 0 && dias <= 60) cntEquiposPorCaducar += 1;
                            }
                        } else if (estado === 'VENCIDA') {
                            cntEquiposVenc += 1;
                        } else {
                            cntEquiposSin += 1;
                        }
                    });
                    lblResVig.textContent = String(cntEquiposVig);
                    lblResVenc.textContent = String(cntEquiposVenc);
                    lblResSin.textContent = String(cntEquiposSin);
                    if (lblResPorCad) lblResPorCad.textContent = String(cntEquiposPorCaducar);
                    if (lblResCaducadas) lblResCaducadas.textContent = String(cntEquiposVenc);
                }
            } catch {}
        }

        function limpiarConteosCsvPreview() {
            _csvPreviewActive = false;
            _csvPreviewRows = [];
            actualizarContadoresTiposLocal(pruebas);
            render();
        }

        async function cargarInventarioDesdeCsv() {
            try {
                const resp = await fetch('docs/invre.csv');
                if (!resp.ok) return;
                const texto = await resp.text();
                const parsed = parseCsv(texto);
                const headers = parsed.headers || [];
                const rows = parsed.rows || [];
                if (!headers.length || !rows.length) return;

                const idxEquipo = headers.indexOf('EQUIPO / ACTIVO');
                const idxSerial = headers.indexOf('SERIAL');
                const idxDesc = headers.indexOf('DESCRIPCION');
                const idxProd = headers.indexOf('PRODUCTO');
                const idxEdo = headers.indexOf('EDO');
                if (idxEquipo < 0) return;

                const setEq = new Set();
                const mapaDesc = {};
                const mapaProd = {};
                const mapaDescSerial = {};
                const mapaProdSerial = {};
                const mapaSerialPorEquipo = {};
                const mapaEdo = {};

                rows.forEach(cols => {
                    let eq = normEquipoKey((cols[idxEquipo] || '').toString());
                    const serial = ((idxSerial>=0 ? cols[idxSerial] : '') || '').toString().trim().toUpperCase();
                    if (!eq) return;
                    setEq.add(eq);
                    if (serial && !mapaSerialPorEquipo[eq]) mapaSerialPorEquipo[eq] = serial;
                    if (idxEdo >= 0) {
                        const edo = (cols[idxEdo] || '').toString().trim().toUpperCase();
                        if (edo && !mapaEdo[eq]) mapaEdo[eq] = edo;
                    }
                    if (idxDesc >= 0) {
                        const desc = (cols[idxDesc] || '').toString().trim();
                        if (desc && !mapaDesc[eq]) mapaDesc[eq] = desc;
                        if (serial && desc && !mapaDescSerial[serial]) mapaDescSerial[serial] = desc;
                    }
                    if (idxProd >= 0) {
                        const prod = (cols[idxProd] || '').toString().trim();
                        if (prod && !mapaProd[eq]) mapaProd[eq] = prod;
                        if (serial && prod && !mapaProdSerial[serial]) mapaProdSerial[serial] = prod;
                    }
                });

                try {
                    const resp2 = await fetch('docs/invre2.csv');
                    if (resp2.ok) {
                        const texto2 = await resp2.text();
                        const parsed2 = parseCsv(texto2);
                        const headers2 = parsed2.headers || [];
                        const rows2 = parsed2.rows || [];
                        const idxEquipo2 = headers2.indexOf('EQUIPO / ACTIVO');
                        const idxSerial2 = headers2.indexOf('SERIAL');
                        const idxDesc2 = headers2.indexOf('DESCRIPCION');
                        const idxProd2 = headers2.indexOf('PRODUCTO');
                        // Heur√≠stica: en invre2, despu√©s de ACERO vienen columnas para tipo de prueba y √°rea.
                        const idxAcero2 = headers2.indexOf('ACERO');
                        const idxTipoPrueba2 = (idxAcero2 >= 0) ? (idxAcero2 + 1) : -1; // 'LT' | 'VT / PT / MT' | 'UTT' ...
                        const idxArea2 = (idxAcero2 >= 0) ? (idxAcero2 + 3) : -1;      // √Årea inspecci√≥n (e.g., CAVIDAD, CARA, PARED)
                        if (idxEquipo2 >= 0 && rows2.length) {
                            rows2.forEach(cols2 => {
                                let eq2 = normEquipoKey((cols2[idxEquipo2] || '').toString());
                                const serial2 = ((idxSerial2>=0 ? cols2[idxSerial2] : '') || '').toString().trim().toUpperCase();
                                if (!eq2) return;
                                setEq.add(eq2);
                                if (serial2 && !mapaSerialPorEquipo[eq2]) mapaSerialPorEquipo[eq2] = serial2;
                                if (idxDesc2 >= 0) {
                                    const desc2 = (cols2[idxDesc2] || '').toString().trim();
                                    if (desc2 && !mapaDesc[eq2]) mapaDesc[eq2] = desc2;
                                    if (serial2 && desc2 && !mapaDescSerial[serial2]) mapaDescSerial[serial2] = desc2;
                                }
                                if (idxProd2 >= 0) {
                                    const prod2 = (cols2[idxProd2] || '').toString().trim();
                                    if (prod2 && !mapaProd[eq2]) mapaProd[eq2] = prod2;
                                    if (serial2 && prod2 && !mapaProdSerial[serial2]) mapaProdSerial[serial2] = prod2;
                                }
                                // Mapear √°rea por equipo/serial y tipo de prueba si est√°n las columnas
                                if (idxTipoPrueba2 >= 0 && idxArea2 >= 0) {
                                    const tipo2 = (cols2[idxTipoPrueba2] || '').toString().trim().toUpperCase();
                                    const area2 = (cols2[idxArea2] || '').toString().trim();
                                    if (tipo2 && area2) {
                                        const keyEq = `${eq2}::${tipo2}`;
                                        if (!areaPorEquipoPruebaInv[keyEq]) areaPorEquipoPruebaInv[keyEq] = area2;
                                        if (serial2) {
                                            const keySn = `${serial2}::${tipo2}`;
                                            if (!areaPorSerialPruebaInv[keySn]) areaPorSerialPruebaInv[keySn] = area2;
                                        }
                                    }
                                }
                            });
                        }
                    }
                } catch {}

                equiposInventario = setEq;
                descripcionPorEquipoInv = mapaDesc;
                productoPorEquipoInv = mapaProd;
                descripcionPorSerialInv = mapaDescSerial;
                productoPorSerialInv = mapaProdSerial;
                serialPorEquipoInv = mapaSerialPorEquipo;
                edoPorEquipoInv = mapaEdo;
            } catch (e) {
                console.warn('No se pudo cargar invre.csv para resumen de pruebas', e);
            }
        }

        await cargarInventarioDesdeCsv();

        // ================== Importaci√≥n CSV (solo admin) ==================
        let importRowsReady = [];
        let existingKeys = new Set();
        let lastCsvText = '';

        function composeKey(r) {
            const equipo = (r.equipo||'').trim().toUpperCase();
            const numeroSerie = (r.numeroSerie||r.serial||'').trim().toUpperCase();
            const periodo = (r.periodo||'').trim().toUpperCase();
            const prueba = (r.prueba||'').trim().toUpperCase();
            const fechaRealizacion = (r.fechaRealizacion||'').trim();
            const noReporte = (r.noReporte||'').trim().toUpperCase();
            const area = (r.area||r.areaPrueba||'').trim().toUpperCase();
            if (!equipo || !numeroSerie || !periodo || !prueba || !fechaRealizacion || !noReporte || !area) return '';
            return `${equipo}__${numeroSerie}__${periodo}__${prueba}__${fechaRealizacion}__${noReporte}__${area}`;
        }
        try { window.composeKey = composeKey; } catch {}

        function normalizeNoReporte(s) {
            let t = String(s || '').trim().toUpperCase();
            t = t.replace(/\s+/g, '');
            t = t.replace(/[^A-Z0-9-]/g, '');
            t = t.replace(/-+/g, '-');
            t = t.replace(/^-/, '').replace(/-$/, '');
            return t;
        }

        function composeKeyRelaxed(r) {
            const equipo = (r.equipo||'').trim().toUpperCase();
            const numeroSerie = (r.numeroSerie||r.serial||'').trim().toUpperCase();
            const periodo = (r.periodo||'').trim().toUpperCase();
            const prueba = (r.prueba||'').trim().toUpperCase();
            const fechaRealizacion = (r.fechaRealizacion||'').trim();
            let noReporte = (r.noReporte||'').trim().toUpperCase();
            const area = (r.area||r.areaPrueba||'').trim().toUpperCase();
            if (!equipo || !numeroSerie || !periodo || !prueba || !fechaRealizacion || !noReporte || !area) return '';
            noReporte = normalizeNoReporte(noReporte);
            return `${equipo}__${numeroSerie}__${periodo}__${prueba}__${fechaRealizacion}__${noReporte}__${area}`;
        }
        try { window.composeKeyRelaxed = composeKeyRelaxed; } catch {}

        function buildExistingKeys() {
            existingKeys = new Set();
            (pruebas||[]).forEach(reg => {
                const k = composeKey({
                    equipo: reg.equipo,
                    numeroSerie: reg.serial || reg.numeroSerie,
                    periodo: reg.periodo,
                    prueba: reg.prueba,
                    fechaRealizacion: reg.fechaRealizacion,
                    noReporte: reg.noReporte,
                    area: reg.area,
                });
                if (k) existingKeys.add(k);
            });
        }
        buildExistingKeys();
        // Exponer utilidades para handlers definidos fuera de este alcance
        try {
            window.buildExistingKeys = buildExistingKeys;
            window.getExistingKeysSet = () => existingKeys;
            window.getImportRowsReady = () => importRowsReady;
            window.getLastCsvText = () => lastCsvText;
        } catch {}

        function parseCsv(text) {
            const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
            if (!lines.length) return { headers: [], rows: [] };
            const parseLine = (line) => {
                const out = [];
                let cur = '';
                let inside = false;
                for (let i=0;i<line.length;i++) {
                    const ch = line[i];
                    if (ch === '"') {
                        if (inside && line[i+1] === '"') { cur += '"'; i++; }
                        else inside = !inside;
                    } else if (ch === ',' && !inside) {
                        out.push(cur); cur = '';
                    } else {
                        cur += ch;
                    }
                }
                out.push(cur);
                return out;
            };
            const headers = parseLine(lines[0]).map(h => String(h||'').trim());
            const rows = lines.slice(1).map(l => parseLine(l));
            return { headers, rows };
        }

        function req(val) { return val !== undefined && val !== null && String(val).trim() !== ''; }
        function isValidPeriodo(p) { const v = String(p||'').toUpperCase(); return v==='ANUAL' || v==='POST-TRABAJO' || v==='REPARACION'; }
        function normalizaPrueba(p) {
            try {
                const v = String(p || '').toUpperCase().trim();
                if (!v) return '';
                // Normalizar variantes comunes a un valor can√≥nico
                // Ej: "VT / PT / MT" , "VT/PT/MT" , "VT-PT-MT" => "VT/PT/MT"
                const compact = v.replace(/\s+/g, '');
                if (compact === 'VT/PT/MT' || compact === 'VT/PT/MT,' || compact === 'VT/PT/MT;') return 'VT/PT/MT';
                if (compact === 'VT/PT/MT'.replace(/\//g,'') ) return 'VT/PT/MT';
                if (compact === 'VT/PT/MT') return 'VT/PT/MT';
                if (compact === 'VT/PT/MT' || compact === 'VT/PT/MT') return 'VT/PT/MT';
                if (compact === 'VT/PT/MT') return 'VT/PT/MT';
                if (compact === 'VT/PT/MT') return 'VT/PT/MT';
                if (compact === 'VT/PT/MT') return 'VT/PT/MT';
                if (compact === 'VT/PT/MT') return 'VT/PT/MT';
                // Detecci√≥n por contenido para cadena con separadores
                if (compact.includes('VT') && compact.includes('PT') && compact.includes('MT') && !compact.includes('UTT') && !compact.includes('LT')) {
                    return 'VT/PT/MT';
                }
                return v;
            } catch {
                return String(p || '').toUpperCase().trim();
            }
        }
        function isValidResultado(r) {
            const v = String(r||'').toUpperCase();
            return v==='ACEPTADA' || v==='APROBADA' || v==='APROBADO' || v==='RECHAZADA' || v==='N/A';
        }
        function normalizaResultado(r) {
            const v = String(r||'').toUpperCase();
            if (v==='APROBADA' || v==='APROBADO') return 'ACEPTADA';
            return v;
        }
        function normalizaEjecucion(e) {
            const v = String(e||'').toUpperCase();
            if (v==='EXTERNA') return 'EXTERNO';
            if (v==='INTERNA') return 'INTERNO';
            return v;
        }
        function isValidEjecucion(e) {
            if (!e) return true;
            const v = normalizaEjecucion(e);
            return v==='INTERNO' || v==='EXTERNO';
        }
        function parseFechaDDMMAAAA(s) {
            const t = String(s||'').trim();
            // Acepta dd/mm/aa o dd/mm/aaaa
            const m = t.match(/^([0-3]?\d)\/([0-1]?\d)\/(\d{2}|\d{4})$/);
            if (!m) return null;
            const dd = parseInt(m[1],10), mm = parseInt(m[2],10);
            let yyyy = parseInt(m[3],10);
            if (m[3].length === 2) { yyyy = 2000 + yyyy; }
            const d = new Date(yyyy, mm-1, dd); d.setHours(0,0,0,0);
            return isNaN(d.getTime()) ? null : d;
        }
        function formatDDMMAAAA(d) {
            const dd = String(d.getDate()).padStart(2,'0');
            const mm = String(d.getMonth()+1).padStart(2,'0');
            const yyyy = d.getFullYear();
            return `${dd}/${mm}/${yyyy}`;
        }
        function addDays(d, days) { const nd = new Date(d.getTime()); nd.setDate(nd.getDate()+days); return nd; }

        function validateCsv(text) {
            const expectHeaders = ['cliente','equipo','numeroSerie','periodo','prueba','fechaRealizacion','noReporte','resultado','ejecucion','emisor','pruebaDetalle','observaciones','ubicacion','areaPrueba','tecnico','proxima'];
            const { headers, rows } = parseCsv(text);
            const hdrStr = headers.join(',');
            const okHeaders = expectHeaders.join(',') === hdrStr;
            const errors = [];
            const warnings = [];
            const valids = [];
            if (!okHeaders) {
                errors.push(`Encabezados inv√°lidos. Se esperaba: ${expectHeaders.join(',')}. Se obtuvo: ${hdrStr}`);
                return { valids, errors, warnings };
            }

            // Mapear √°reas previas conocidas por equipo/serial a partir de lo ya cargado
            const areaPorEquipoPrev = {};
            const areaPorSerialPrev = {};
            (pruebas || []).forEach(reg => {
                const eqK = (reg && reg.equipo ? String(reg.equipo).trim().toUpperCase() : '');
                const snK = (reg && (reg.serial || reg.numeroSerie) ? String(reg.serial || reg.numeroSerie).trim().toUpperCase() : '');
                const areaK = reg && reg.area ? String(reg.area).trim() : '';
                if (areaK) {
                    if (eqK && !areaPorEquipoPrev[eqK]) areaPorEquipoPrev[eqK] = areaK;
                    if (snK && !areaPorSerialPrev[snK]) areaPorSerialPrev[snK] = areaK;
                }
            });

            rows.forEach((cols, idx) => {
                const n = idx + 2; // l√≠nea real
                const rec = Object.fromEntries(headers.map((h,i)=>[h, cols[i]!==undefined? String(cols[i]).trim() : '']));
                // Omitir filas totalmente vac√≠as (todas las columnas en blanco)
                const allEmpty = Object.values(rec).every(v => !req(v));
                if (allEmpty) { warnings.push(`L${n}: fila vac√≠a (omitida)`); return; }
                // Requeridos
                if (!req(rec.cliente)) errors.push(`L${n}: cliente requerido`);
                if (!req(rec.equipo)) errors.push(`L${n}: equipo requerido`);
                if (!req(rec.numeroSerie)) errors.push(`L${n}: numeroSerie requerido`);
                if (!req(rec.periodo) || !isValidPeriodo(rec.periodo)) errors.push(`L${n}: periodo inv√°lido (ANUAL|POST-TRABAJO|REPARACION)`);
                if (!req(rec.prueba)) errors.push(`L${n}: prueba requerida`);
                const f = parseFechaDDMMAAAA(rec.fechaRealizacion);
                if (!req(rec.fechaRealizacion) || !f) errors.push(`L${n}: fechaRealizacion inv√°lida (dd/mm/aa o dd/mm/aaaa)`);
                if (!req(rec.noReporte)) errors.push(`L${n}: noReporte requerido`);
                if (!req(rec.resultado) || !isValidResultado(rec.resultado)) errors.push(`L${n}: resultado inv√°lido (APROBADA|APROBADO|RECHAZADA|N/A)`);
                if (!isValidEjecucion(rec.ejecucion)) errors.push(`L${n}: ejecucion inv√°lida (INTERNO|INTERNA|EXTERNO|EXTERNA)`);
                // Relajar: si ejecucion=EXTERNO sin emisor, marcar warning y permitir la fila
                if (normalizaEjecucion(rec.ejecucion||'')==='EXTERNO' && !req(rec.emisor)) warnings.push(`L${n}: emisor ausente con ejecucion=EXTERNO (se permitir√° la carga)`);
                const pruebaNormTmp = normalizaPrueba(rec.prueba || '');
                const requiereDetalleVpm = (pruebaNormTmp === 'VT' || pruebaNormTmp === 'PT' || pruebaNormTmp === 'MT' || pruebaNormTmp === 'VT/PT/MT');

                // Inventario
                if (equiposInventario && equiposInventario.size && !equiposInventario.has(rec.equipo)) {
                    warnings.push(`L${n}: equipo no encontrado en inventario (se permitir√° la carga)`);
                }

                // Duplicados
                const k = composeKey(rec);
                if (existingKeys.has(k)) warnings.push(`L${n}: duplicado detectado (se omitir√° en la importaci√≥n)`);

                const hasRowError = errors.some(e => e.startsWith(`L${n}:`));
                if (!hasRowError) {
                    const periodo = String(rec.periodo).toUpperCase();
                    // Pr√≥xima para ANUAL
                    let proxima = '';
                    if (periodo === 'ANUAL' && req(rec.proxima)) {
                        const p = parseFechaDDMMAAAA(rec.proxima);
                        if (p) proxima = formatDDMMAAAA(p);
                        else warnings.push(`L${n}: proxima inv√°lida; se calcular√° autom√°ticamente`);
                    }
                    if (periodo === 'ANUAL' && !proxima && f) proxima = formatDDMMAAAA(addDays(f, 365));
                    // Emisor para INTERNO
                    let emisor = rec.emisor || '';
                    if (String(rec.ejecucion||'').toUpperCase()==='INTERNO') emisor = 'PCT';
                    // Producto/Descripci√≥n desde inventario por equipo
                    const eqKey = (rec.equipo || '').toString().trim().toUpperCase();
                    const serialKey = (rec.numeroSerie || '').toString().trim().toUpperCase();
                    const producto = (productoPorEquipoInv && productoPorEquipoInv[eqKey])
                        ? productoPorEquipoInv[eqKey]
                        : (productoPorSerialInv && productoPorSerialInv[serialKey])
                            ? productoPorSerialInv[serialKey]
                            : (rec.producto || '');
                    const descripcion = (descripcionPorEquipoInv && descripcionPorEquipoInv[eqKey])
                        ? descripcionPorEquipoInv[eqKey]
                        : (descripcionPorSerialInv && descripcionPorSerialInv[serialKey])
                            ? descripcionPorSerialInv[serialKey]
                            : (rec.descripcion || '');

                    // Resolver √°rea: CSV -> inventario (invre2) por equipo/serial+tipo -> previo por equipo -> previo por serial
                    let tipoKey = normalizaPrueba(rec.prueba || '');
                    // En invre2 el tipo suele venir como "VT / PT / MT" (con espacios)
                    if (tipoKey === 'VT' || tipoKey === 'PT' || tipoKey === 'MT' || tipoKey === 'VT/PT/MT') {
                        tipoKey = 'VT / PT / MT';
                    }
                    const areaInv = (areaPorEquipoPruebaInv && areaPorEquipoPruebaInv[`${eqKey}::${tipoKey}`])
                        ? areaPorEquipoPruebaInv[`${eqKey}::${tipoKey}`]
                        : (areaPorSerialPruebaInv && areaPorSerialPruebaInv[`${serialKey}::${tipoKey}`])
                            ? areaPorSerialPruebaInv[`${serialKey}::${tipoKey}`]
                            : '';
                    const areaResolved = rec.areaPrueba || areaInv || areaPorEquipoPrev[eqKey] || areaPorSerialPrev[serialKey] || '';
                    if (!areaResolved) {
                        warnings.push(`L${n}: √°rea de inspecci√≥n no encontrada (equipo/serial/tipo sin coincidencia en invre2 y sin antecedente)`);
                    }

                    // Normalizar pruebaDetalle para VT/PT/MT: si viene vac√≠o, autocompletar con el √°rea.
                    // Esto evita rechazar CSVs donde el detalle no est√° separado, pero s√≠ hay √°rea.
                    let pruebaDetalleNorm = (rec.pruebaDetalle || '').toString().trim();
                    if (requiereDetalleVpm && !pruebaDetalleNorm) {
                        pruebaDetalleNorm = (rec.areaPrueba || areaResolved || '').toString().trim();
                        if (pruebaDetalleNorm) warnings.push(`L${n}: pruebaDetalle ausente para VT/PT/MT; se usar√° √°rea "${pruebaDetalleNorm}"`);
                        else warnings.push(`L${n}: pruebaDetalle ausente para VT/PT/MT y no hay √°rea; se permitir√° vac√≠o`);
                    }

                    valids.push({
                        cliente: rec.cliente,
                        equipo: rec.equipo,
                        serial: rec.numeroSerie,
                        periodo,
                        prueba: normalizaPrueba(rec.prueba || ''),
                        fechaRealizacion: formatDDMMAAAA(f),
                        noReporte: rec.noReporte,
                        resultado: normalizaResultado(rec.resultado),
                        ejecucion: normalizaEjecucion(rec.ejecucion||''),
                        emisor,
                        producto,
                        descripcion,
                        pruebaDetalle: pruebaDetalleNorm || '',
                        observaciones: rec.observaciones || '',
                        ubicacion: rec.ubicacion || '',
                        area: areaResolved,
                        tecnico: rec.tecnico || '',
                        proxima
                    });
                }
            });

            return { valids, errors, warnings };
        }

        function renderImportPreview(res) {
            if (!importPreview) return;
            const total = (res.valids?.length||0) + (res.errors?.filter(e=>/^L\d+:/.test(e)).length||0);
            importSummary.innerHTML = `Registros v√°lidos: <strong>${res.valids.length}</strong> de ${total}`;
            importWarnings.innerHTML = res.warnings.length ? (`<ul>` + res.warnings.slice(0,50).map(w=>`<li>${w}</li>`).join('') + (res.warnings.length>50?`<li>... (${res.warnings.length-50} m√°s)</li>`:'') + `</ul>`) : '';
            importErrors.innerHTML = res.errors.length ? (`<ul>` + res.errors.slice(0,50).map(e=>`<li>${e}</li>`).join('') + (res.errors.length>50?`<li>... (${res.errors.length-50} m√°s)</li>`:'') + `</ul>`) : '';
            importPreview.style.display = '';
            const hasErrors = (res.errors && res.errors.length > 0);
            if (btnImportConfirm) {
                btnImportConfirm.style.display = '';
                btnImportConfirm.disabled = hasErrors || !res.valids.length;
            }
            if (btnImportDeleteExisting) {
                btnImportDeleteExisting.style.display = '';
                // Mantener habilitado para que muestre alerta si no es admin
                btnImportDeleteExisting.disabled = !res.valids.length;
            }
            const btnDiagnose = document.getElementById('btn-import-diagnose-missing');
            if (btnDiagnose) {
                btnDiagnose.style.display = (window.isAdmin && res.valids.length) ? '' : 'none';
                btnDiagnose.disabled = !res.valids.length;
            }
            const btnDiagExisting = document.getElementById('btn-import-diagnose-existing-only');
            if (btnDiagExisting) {
                // Mostrar si hay datos cargados en lista y hay CSV v√°lido
                const hasExisting = (pruebas && pruebas.length) ? true : false;
                btnDiagExisting.style.display = (window.isAdmin && hasExisting && res.valids.length) ? '' : 'none';
                btnDiagExisting.disabled = !(hasExisting && res.valids.length);
            }
            const btnSummarySets = document.getElementById('btn-import-summary-sets');
            if (btnSummarySets) {
                const hasExisting = (pruebas && pruebas.length) ? true : false;
                btnSummarySets.style.display = (window.isAdmin && hasExisting && res.valids.length) ? '' : 'none';
                btnSummarySets.disabled = !(hasExisting && res.valids.length);
            }
            const btnReconcile = document.getElementById('btn-import-reconcile');
            if (btnReconcile) {
                const hasExisting = (pruebas && pruebas.length) ? true : false;
                btnReconcile.style.display = (window.isAdmin && hasExisting && res.valids.length) ? '' : 'none';
                btnReconcile.disabled = !(hasExisting && res.valids.length);
            }
            const btnExportErrors = document.getElementById('btn-import-export-errors');
            if (btnExportErrors) {
                btnExportErrors.style.display = hasErrors ? '' : 'none';
                btnExportErrors.disabled = !hasErrors;
            }
            if (btnImportCancel) btnImportCancel.style.display = '';
            const note = document.getElementById('import-note');
            if (note) note.style.display = hasErrors ? '' : 'none';

            // Modo evento: nunca sobrescribe, solo inserta eventos nuevos.
            try {
                const chkOv = document.getElementById('chk-import-overwrite');
                const chkAuto = document.getElementById('chk-auto-import');
                if (chkOv) {
                    chkOv.checked = false;
                    chkOv.disabled = true;
                    const lbl = chkOv.closest('label');
                    if (lbl) lbl.style.display = 'none';
                }
                if (chkAuto) {
                    chkAuto.checked = false;
                    chkAuto.disabled = true;
                    const lbl2 = chkAuto.closest('label');
                    if (lbl2) lbl2.style.display = 'none';
                }
            } catch {}
        }

        async function doImportToFirestore(rows) {
            const { getFirestore, collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js');
            const db = (window && window.db) ? window.db : getFirestore();
            let ok = 0, updated = 0, skipped = 0, failed = 0;
            let importBatchId = '';
            try {
                importBatchId = `pruebas_${new Date().toISOString()}_${Math.random().toString(36).slice(2, 8)}`;
            } catch { importBatchId = `pruebas_${Date.now()}`; }
            for (const r of rows) {
                const k = composeKey({
                    equipo: r.equipo,
                    numeroSerie: r.serial,
                    periodo: r.periodo,
                    prueba: r.prueba,
                    fechaRealizacion: r.fechaRealizacion,
                    noReporte: r.noReporte,
                    area: r.area,
                });
                // Modo evento: si ya existe la misma llave del evento, se omite.
                if (existingKeys.has(k)) { skipped++; continue; }
                const payload = {
                    cliente: r.cliente,
                    equipo: r.equipo,
                    serial: r.serial,
                    periodo: r.periodo,
                    prueba: r.prueba,
                    fechaRealizacion: r.fechaRealizacion,
                    noReporte: r.noReporte,
                    resultado: r.resultado,
                    ejecucion: r.ejecucion,
                    emisor: r.emisor,
                    producto: r.producto,
                    descripcion: r.descripcion,
                    pruebaDetalle: r.pruebaDetalle,
                    observaciones: r.observaciones,
                    ubicacion: r.ubicacion,
                    area: r.area || '',
                    tecnico: r.tecnico,
                    creadoEn: serverTimestamp(),
                    importBatchId,
                    importedAt: serverTimestamp(),
                };
                if (r.periodo === 'ANUAL' && r.proxima) payload.proxima = r.proxima;
                try {
                    await addDoc(collection(db, 'pruebas'), payload);
                    existingKeys.add(k);
                    ok++;
                    if (((ok + updated) % 50) === 0 && importSummary) {
                        importSummary.innerHTML = `Importando... <strong>${ok + updated}</strong> / ${rows.length}`;
                    }
                } catch (e) {
                    failed++;
                    console.error('Error insertando fila import', e);
                }
            }
            try {
                if (ok > 0 && importBatchId) localStorage.setItem('pct_pruebas_last_import_batch_id', String(importBatchId));
            } catch {}
            return { ok, updated, skipped, failed };
        }

        async function deleteExistingFromCsv(rows) {
            const { getFirestore, collection, getDocs, deleteDoc, doc } = await import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js');
            const db = (window.db || getFirestore());
            // Construir mapa key->docId de Firestore
            const colRef = collection(db, 'pruebas');
            const snap = await getDocs(colRef);
            const mapFs = new Map();
            snap.docs.forEach(d => {
                const data = d.data();
                const k = composeKey({
                    equipo: data.equipo,
                    numeroSerie: data.serial || data.numeroSerie,
                    periodo: data.periodo,
                    prueba: data.prueba,
                    fechaRealizacion: data.fechaRealizacion,
                    noReporte: data.noReporte,
                    area: data.area,
                });
                if (k) mapFs.set(k, d.id);
            });

            let delOk = 0, delMiss = 0, delFail = 0;
            let processed = 0;
            for (const r of rows) {
                const k = composeKey({
                    equipo: r.equipo,
                    numeroSerie: r.serial,
                    periodo: r.periodo,
                    prueba: r.prueba,
                    fechaRealizacion: r.fechaRealizacion,
                    noReporte: r.noReporte,
                    area: r.area,
                });
                const id = mapFs.get(k);
                if (!id) { delMiss++; continue; }
                try {
                    await deleteDoc(doc(db, 'pruebas', id));
                    delOk++;
                } catch (e) {
                    console.error('Error eliminando doc', e);
                    delFail++;
                }
                processed++;
                if (processed % 50 === 0 && importSummary) {
                    importSummary.innerHTML = `Eliminando... <strong>${processed}</strong> / ${rows.length}`;
                }
            }
            return { delOk, delMiss, delFail };
        }

        if (btnImportCsv && inputImportCsv) {
            btnImportCsv.addEventListener('click', () => inputImportCsv.click());
            inputImportCsv.addEventListener('change', async (ev) => {
                const file = ev.target.files && ev.target.files[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    lastCsvText = text;
                    const res = validateCsv(text);
                    importRowsReady = res.valids;
                    window.__lastValidationResult = res;
                    renderImportPreview(res);
                    try { aplicarConteosDesdeCsvPreview(importRowsReady || []); } catch {}
                } catch (e) {
                    alert('No se pudo leer el archivo CSV');
                    setProcessingGuard(false);
                }
            });
        }

        // Diagn√≥stico: CSV vs pruebas existentes
        const btnDiagnoseMissing = document.getElementById('btn-import-diagnose-missing');
        if (btnDiagnoseMissing) {
            btnDiagnoseMissing.addEventListener('click', async () => {
                try {
                    // Asegurar llaves actuales de lo que est√° cargado
                    if (window.buildExistingKeys) window.buildExistingKeys();
                    let rows = (window.getImportRowsReady && window.getImportRowsReady()) || [];
                    if (!rows.length && (window.getLastCsvText && window.getLastCsvText())) {
                        const r = validateCsv(window.getLastCsvText());
                        rows = r.valids || [];
                    }
                    if (!rows.length) {
                        alert('Primero selecciona el CSV para diagnosticar.');
                        return;
                    }
                    const csvKeys = new Set();
                    rows.forEach(r => {
                        const k = composeKey({
                            equipo: r.equipo,
                            numeroSerie: r.serial,
                            periodo: r.periodo,
                            prueba: r.prueba,
                            fechaRealizacion: r.fechaRealizacion,
                            noReporte: r.noReporte,
                            area: r.area,
                        });
                        if (k) csvKeys.add(k);
                    });
                    const exSet = (window.getExistingKeysSet && window.getExistingKeysSet()) || existingKeys || new Set();
                    const missing = [];
                    csvKeys.forEach(k => { if (!exSet.has(k)) missing.push(k); });
                    if (!missing.length) {
                        importErrors.innerHTML = 'Sin faltantes: todas las filas del CSV est√°n presentes en la lista.';
                    } else {
                        const sample = missing.slice(0, 15).map(x => `<li>${x}</li>`).join('');
                        importErrors.innerHTML = `<div>Faltantes detectados: <strong>${missing.length}</strong></div><ul>${sample}</ul>` + (missing.length>15?`<div>... y ${missing.length-15} m√°s</div>`:'');
                    }
                } catch (e) {
                    console.error('Diagn√≥stico de faltantes fall√≥', e);
                    alert('No fue posible ejecutar el diagn√≥stico.');
                }
            });
        }

        if (btnImportConfirm) {
            btnImportConfirm.addEventListener('click', async () => {
                if (!(window.isAdmin || window.isDirector || window.isAuxger)) return;
                btnImportConfirm.disabled = true;
                try {
                    // Salir del modo vista previa CSV: despu√©s de importar, el origen de verdad es Firestore
                    try {
                        _csvPreviewActive = false;
                        _csvPreviewRows = [];
                    } catch {}

                    const res = await doImportToFirestore(importRowsReady||[]);
                    importSummary.innerHTML += ` ‚Äî Importados: <strong>${res.ok}</strong>, Actualizados: <strong>${res.updated}</strong>, Omitidos (duplicados): ${res.skipped}, Fallidos: ${res.failed}`;
                    // Recargar listado
                    const desdeFs2 = await leerFirestore();
                    if (desdeFs2 && Array.isArray(desdeFs2)) pruebas = desdeFs2;
                    buildExistingKeys();

                    // Refrescar conteo cacheado para evitar que se quede en 1685 bajo 429/cooldown
                    // Cuando solo hay 200 cargadas, el conteo real cargado no sirve; usar incremento por importaci√≥n.
                    try {
                        const prevCached = parseInt(String(localStorage.getItem('pct_pruebas_total_cached') || ''), 10);
                        const okImported = Number(res && res.ok ? res.ok : 0);
                        const loadedCount = (existingKeys && typeof existingKeys.size === 'number' && existingKeys.size > 0)
                            ? existingKeys.size
                            : (Array.isArray(pruebas) ? pruebas.length : 0);
                        let nextCached = 0;
                        if (Number.isFinite(prevCached) && prevCached > 0 && Number.isFinite(okImported) && okImported > 0) {
                            nextCached = prevCached + okImported;
                        } else {
                            nextCached = Math.max((Number.isFinite(prevCached) ? prevCached : 0), loadedCount);
                        }
                        if (nextCached > 0) {
                            localStorage.setItem('pct_pruebas_total_cached', String(nextCached));
                            _totalServer = nextCached;
                        }
                    } catch {}

                    // Cerrar/limpiar vista previa CSV para evitar que el UI siga mostrando conteos del CSV
                    try {
                        if (importPreview) importPreview.style.display = 'none';
                        if (importWarnings) importWarnings.innerHTML = '';
                        if (importErrors) importErrors.innerHTML = '';
                        if (btnImportConfirm) btnImportConfirm.style.display = 'none';
                        if (btnImportDeleteExisting) btnImportDeleteExisting.style.display = 'none';
                        if (btnImportCancel) btnImportCancel.style.display = 'none';
                        importRowsReady = [];
                        lastCsvText = '';
                        if (inputImportCsv) inputImportCsv.value = '';
                    } catch {}

                    // Forzar refresco de chips de tipo con base en Firestore ya recargado
                    try { actualizarContadoresTiposLocal(pruebas); } catch {}
                    render();
                } finally {
                    btnImportConfirm.disabled = false;
                }
            });
        }

        if (btnImportCancel) {
            btnImportCancel.addEventListener('click', () => {
                if (importPreview) importPreview.style.display = 'none';
                if (importSummary) importSummary.innerHTML = '';
                if (importWarnings) importWarnings.innerHTML = '';
                if (importErrors) importErrors.innerHTML = '';
                importRowsReady = [];
                if (inputImportCsv) inputImportCsv.value = '';
                try { limpiarConteosCsvPreview(); } catch {}
            });
        }

        // Helpers para formatear 'Fecha de registro' (usa creadoEn con fallback a fechaPrueba)
        function toDateGeneric(val) {
            if (!val) return null;
            try {
                if (val && typeof val === 'object' && typeof val.toDate === 'function') {
                    return val.toDate();
                }
                if (val instanceof Date) return new Date(val);
                if (typeof val === 'number' && isFinite(val)) return new Date(val);
                const s = String(val).trim();
                if (!s) return null;
                const d = new Date(s);
                return isNaN(d.getTime()) ? null : d;
            } catch { return null; }
        }

        function formatoFechaHora(d) {
            if (!d || isNaN(d.getTime())) return '';
            const dd = String(d.getDate()).padStart(2, '0');
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const yyyy = d.getFullYear();
            const hh = String(d.getHours()).padStart(2, '0');
            const mi = String(d.getMinutes()).padStart(2, '0');
            return `${dd}/${mm}/${yyyy} ${hh}:${mi}`;
        }

        function obtenerFechaRegistroTexto(reg) {
            const d = toDateGeneric(reg && reg.creadoEn);
            if (d) return formatoFechaHora(d);
            const d2 = toDateGeneric(reg && reg.fechaPrueba);
            return d2 ? formatoFechaHora(d2) : '';
        }

        function parseFechaRealizacion(val) {
            if (!val) return null;
            // Firestore Timestamp
            if (val && typeof val === 'object' && typeof val.toDate === 'function') {
                const d = val.toDate(); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d;
            }
            // Date
            if (val instanceof Date) { const d = new Date(val); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d; }
            // Milliseconds number
            if (typeof val === 'number' && isFinite(val)) { const d = new Date(val); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d; }
            const s = String(val).trim();
            if (!s) return null;
            // dd/mm/aa o dd/mm/aaaa
            if (s.includes('/')) {
                const partes = s.split('/');
                if (partes.length !== 3) return null;
                const [ddStr, mmStr, aaStr] = partes;
                const dd = parseInt(ddStr, 10);
                const mm = parseInt(mmStr, 10);
                const aa = parseInt(aaStr, 10);
                if (!dd || !mm || isNaN(aa)) return null;
                const year = aaStr.length <= 2 ? (2000 + aa) : aa;
                const d = new Date(year, mm - 1, dd);
                d.setHours(0,0,0,0);
                return isNaN(d.getTime()) ? null : d;
            }
            // ISO u otros formatos parseables por Date
            const d = new Date(s);
            if (isNaN(d.getTime())) return null;
            d.setHours(0,0,0,0);
            return d;
        }

        function mostrarDetallePrueba(reg) {
            if (!detalleContenido) return;

            // Construir una clave estable para comparar selecciones repetidas
            const clave =
                (reg && reg.id) ||
                `${reg.equipo || ''}__${reg.fechaRealizacion || ''}__${reg.noReporte || ''}`;

            // Si se hace clic de nuevo sobre la misma prueba, contraer el panel
            if (pruebaSeleccionadaId && pruebaSeleccionadaId === clave) {
                detalleContenido.innerHTML =
                    'No hay ninguna prueba seleccionada.';
                pruebaSeleccionadaId = null;
                return;
            }

            // C√°lculo de d√≠as para pr√≥xima prueba (mismo criterio que en el listado)
            let diasParaProximaDetalle = '';
            if (reg.proxima) {
                const d = parseProxima(reg.proxima);
                if (d) {
                    const hoy = hoySinHora();
                    const diffMs = d.getTime() - hoy.getTime();
                    let dias = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    if (dias < 0) dias = 0;
                    diasParaProximaDetalle = String(dias);
                }
            }

            const campos = [
                ['Equipo', reg.equipo || ''],
                ['Serial', reg.serial || ''],
                ['Producto', reg.producto || ''],
                ['Descripci√≥n', reg.descripcion || ''],
                ['Prueba / Calibraci√≥n', reg.prueba || reg.pruebaTipo || ''],
                ['Resultado', reg.resultado || ''],
                ['Periodo', reg.periodo || ''], 
                ['Fecha de registro', obtenerFechaRegistroTexto(reg)],
                ['Fecha realizaci√≥n', reg.fechaRealizacion || ''],
                ['Pr√≥xima prueba', reg.proxima || ''],
                ['D√≠as para pr√≥xima', diasParaProximaDetalle],
                ['No. reporte / certificado', reg.noReporte || ''],
                ['T√©cnico', reg.tecnico || ''],
                ['Emisor', reg.emisor || ''],
                ['Propiedad', reg.propiedad || ''],
                ['√Årea a inspeccionar', reg.area || ''],
                ['Observaciones', reg.observaciones || '']
            ];

            const filasHtml = campos
                .filter(([_, valor]) => valor !== undefined && valor !== null && String(valor).trim() !== '')
                .map(([label, valor]) => `
                    <tr>
                        <th style="text-align:left; padding:0.2rem 0.5rem; width:180px; color:#4b5563; font-weight:600;">${label}</th>
                        <td style="padding:0.2rem 0.5rem;">${String(valor)}</td>
                    </tr>
                `)
                .join('');

            detalleContenido.innerHTML = `
                <table style="width:100%; border-collapse:collapse; font-size:0.88rem;">
                    <tbody>
                        ${filasHtml || '<tr><td style="padding:0.4rem; color:#6b7280;">Sin datos para esta prueba.</td></tr>'}
                    </tbody>
                </table>
            `;

            pruebaSeleccionadaId = clave;
        }

        // Construir el HTML del detalle (reutiliza las mismas filas de mostrarDetallePrueba)
        function construirDetalleHTML(reg) {
            let diasParaProximaDetalle = '';
            if (reg.proxima) {
                const d = parseProxima(reg.proxima);
                if (d) {
                    const hoy = hoySinHora();
                    const diffMs = d.getTime() - hoy.getTime();
                    let dias = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    if (dias < 0) dias = 0;
                    diasParaProximaDetalle = String(dias);
                }
            }

            const campos = [
                ['Equipo', reg.equipo || ''],
                ['Serial', reg.serial || ''],
                ['Producto', reg.producto || ''],
                ['Descripci√≥n', reg.descripcion || ''],
                ['Prueba / Calibraci√≥n', reg.prueba || reg.pruebaTipo || ''],
                ['Resultado', reg.resultado || ''],
                ['Periodo', reg.periodo || ''],
                ['Fecha de registro', obtenerFechaRegistroTexto(reg)],
                ['Fecha realizaci√≥n', reg.fechaRealizacion || ''],
                ['Pr√≥xima prueba', reg.proxima || ''],
                ['D√≠as para pr√≥xima', diasParaProximaDetalle],
                ['No. reporte / certificado', reg.noReporte || ''],
                ['T√©cnico', reg.tecnico || ''],
                ['Emisor', reg.emisor || ''],
                ['Propiedad', reg.propiedad || ''],
                ['√Årea a inspeccionar', reg.area || ''],
                ['Observaciones', reg.observaciones || '']
            ];

            const filasHtml = campos
                .filter(([_, valor]) => valor !== undefined && valor !== null && String(valor).trim() !== '')
                .map(([label, valor]) => `
                    <tr>
                        <th style="text-align:left; padding:0.2rem 0.5rem; width:180px; color:#4b5563; font-weight:600;">${label}</th>
                        <td style="padding:0.2rem 0.5rem;">${String(valor)}</td>
                    </tr>
                `)
                .join('');

            return `
                <div style="font-size:0.9rem; color:#111827; border:1px solid #e5e7eb; border-radius:0.5rem; padding:0.75rem; background:#f9fafb;">
                    <table style="width:100%; border-collapse:collapse; font-size:0.88rem;">
                        <tbody>
                            ${filasHtml || '<tr><td style="padding:0.4rem; color:#6b7280;">Sin datos para esta prueba.</td></tr>'}
                        </tbody>
                    </table>
                </div>`;
        }

        // Alterna una fila de detalle inmediatamente debajo de la fila clicada
        function toggleDetalleInline(fila, reg) {
            const tbody = fila.parentElement;
            if (!tbody) return;

            // Si ya estaba abierto justo debajo, colapsar y salir
            const next = fila.nextElementSibling;
            if (next && next.classList && next.classList.contains('pl-detalle-row')) {
                next.remove();
                fila.classList.remove('pl-active');
                return;
            }

            // Cerrar cualquier otro detalle abierto previamente
            const abiertos = tbody.querySelectorAll('tr.pl-detalle-row');
            abiertos.forEach(tr => tr.remove());
            tbody.querySelectorAll('tr.pl-active').forEach(tr => tr.classList.remove('pl-active'));

            const detalleTr = document.createElement('tr');
            detalleTr.className = 'pl-detalle-row';
            const detalleTd = document.createElement('td');
            detalleTd.colSpan = permitirEliminar ? 15 : 14; // ajustar si no hay columna de selecci√≥n
            detalleTd.innerHTML = construirDetalleHTML(reg);
            detalleTr.appendChild(detalleTd);
            fila.insertAdjacentElement('afterend', detalleTr);
            fila.classList.add('pl-active');
        }

        const plEditModal = document.getElementById('pl-edit-modal');
        const plEditSubtitle = document.getElementById('pl-edit-subtitle');
        const plEditFechaReal = document.getElementById('pl-edit-fecha-real');
        const plEditProxima = document.getElementById('pl-edit-proxima');
        const plEditMsg = document.getElementById('pl-edit-msg');
        const plEditBtnClose = document.getElementById('pl-edit-close');
        const plEditBtnCancel = document.getElementById('pl-edit-cancel');
        const plEditBtnSave = document.getElementById('pl-edit-save');

        let _plEditReg = null;

        function normalizarFechaDdMmAa(s) {
            const t = (s || '').toString().trim();
            if (!t) return '';
            const solo = t.replace(/[^0-9/]/g, '').slice(0, 8);
            if (solo.length !== 8) return t;
            const dd = solo.slice(0, 2);
            const mm = solo.slice(3, 5);
            const aa = solo.slice(6, 8);
            if (solo[2] !== '/' || solo[5] !== '/') return t;
            return `${dd}/${mm}/${aa}`;
        }

        function cerrarModalEdicion() {
            _plEditReg = null;
            if (plEditFechaReal) plEditFechaReal.value = '';
            if (plEditProxima) plEditProxima.value = '';
            if (plEditMsg) plEditMsg.textContent = '';
            if (plEditModal) plEditModal.style.display = 'none';
        }

        async function guardarEdicionFechas() {
            const reg = _plEditReg;
            if (!reg || !reg.id) return;

            const frStr = normalizarFechaDdMmAa(plEditFechaReal ? plEditFechaReal.value : '');
            const pxStr = normalizarFechaDdMmAa(plEditProxima ? plEditProxima.value : '');

            const frDate = frStr ? parseFechaRealizacion(frStr) : null;
            const pxDate = pxStr ? parseProxima(pxStr) : null;
            if (frStr && !frDate) { if (plEditMsg) plEditMsg.textContent = 'Fecha realizaci√≥n inv√°lida. Usa dd/mm/aa.'; return; }
            if (pxStr && !pxDate) { if (plEditMsg) plEditMsg.textContent = 'Pr√≥xima prueba inv√°lida. Usa dd/mm/aa.'; return; }

            const periodo = (reg.periodo || '').toString().trim().toUpperCase();
            const esAnual = (!periodo || periodo === 'ANUAL');
            if (!esAnual && pxStr) { if (plEditMsg) plEditMsg.textContent = 'Post-trabajo/Reparaci√≥n no usa pr√≥xima prueba. Deja el campo vac√≠o.'; return; }

            const patch = {
                fechaRealizacion: frStr || '',
                proxima: esAnual ? (pxStr || '') : '',
                editadoEn: new Date().toISOString(),
                editadoPor: (window.currentUserEmail || '').toString(),
            };

            if (plEditBtnSave) plEditBtnSave.disabled = true;
            if (plEditMsg) plEditMsg.textContent = 'Guardando...';

            try {
                const { getFirestore, doc, updateDoc } = await import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js');
                const db = getFirestore();
                await updateDoc(doc(db, 'pruebas', reg.id), patch);

                const idx = (pruebas || []).findIndex(x => x && x.id === reg.id);
                if (idx >= 0) {
                    pruebas[idx] = { ...pruebas[idx], ...patch };
                }
                try { localStorage.setItem(claveLocal, JSON.stringify(pruebas)); } catch {}
                try { window.pruebas = window.pctGetPruebas(); } catch {}

                cerrarModalEdicion();
                try { actualizarContadoresTiposLocal(pruebas); } catch {}
                render();
            } catch (e) {
                console.error('No se pudo guardar edici√≥n de fechas', e);
                if (plEditMsg) plEditMsg.textContent = 'No se pudo guardar. Revisa permisos/conexi√≥n.';
            } finally {
                if (plEditBtnSave) plEditBtnSave.disabled = false;
            }
        }

        function abrirModalEdicion(reg) {
            if (!plEditModal) return;
            const puedeEditar = !!(window.isAdmin || window.isSupervisor || window.isDirector);
            if (!puedeEditar) return;
            if (!reg || !reg.id) return;

            _plEditReg = reg;

            if (plEditSubtitle) {
                const eq = (reg.equipo || '').toString();
                const sr = (reg.serial || '').toString();
                const rep = (reg.noReporte || '').toString();
                plEditSubtitle.textContent = `${eq}${sr ? ' ¬∑ ' + sr : ''}${rep ? ' ¬∑ ' + rep : ''}`;
            }
            if (plEditFechaReal) plEditFechaReal.value = (reg.fechaRealizacion || '').toString();

            const periodo = (reg.periodo || '').toString().trim().toUpperCase();
            const esAnual = (!periodo || periodo === 'ANUAL');
            if (plEditProxima) {
                plEditProxima.value = esAnual ? ((reg.proxima || '').toString() || '') : '';
                plEditProxima.disabled = !esAnual;
            }

            if (plEditMsg) plEditMsg.textContent = '';
            plEditModal.style.display = 'flex';
            try { (plEditFechaReal || plEditProxima).focus(); } catch {}
        }

        if (plEditBtnClose) plEditBtnClose.addEventListener('click', cerrarModalEdicion);
        if (plEditBtnCancel) plEditBtnCancel.addEventListener('click', cerrarModalEdicion);
        if (plEditModal) {
            plEditModal.addEventListener('click', (e) => {
                if (e && e.target === plEditModal) cerrarModalEdicion();
            });
        }
        if (plEditBtnSave) plEditBtnSave.addEventListener('click', guardarEdicionFechas);
        if (plEditFechaReal) plEditFechaReal.addEventListener('blur', () => { plEditFechaReal.value = normalizarFechaDdMmAa(plEditFechaReal.value); });
        if (plEditProxima) plEditProxima.addEventListener('blur', () => { plEditProxima.value = normalizarFechaDdMmAa(plEditProxima.value); });

        function hoySinHora() {
            const d = new Date();
            d.setHours(0, 0, 0, 0);
            return d;
        }

        function formateaDDMMAA(d) {
            if (!(d instanceof Date) || isNaN(d.getTime())) return '';
            const dd = String(d.getDate()).padStart(2, '0');
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const aa = String(d.getFullYear()).slice(-2);
            return `${dd}/${mm}/${aa}`;
        }

        function parseProxima(val) {
            if (!val) return null;
            // Firestore Timestamp
            if (val && typeof val === 'object' && typeof val.toDate === 'function') {
                const d = val.toDate(); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d;
            }
            // Date instancia
            if (val instanceof Date) { const d = new Date(val); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d; }
            // Milliseconds
            if (typeof val === 'number' && isFinite(val)) { const d = new Date(val); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d; }
            const s = String(val).trim();
            if (!s) return null;
            // dd/mm/aa o dd/mm/aaaa
            if (s.includes('/')) {
                const partes = s.split('/');
                if (partes.length !== 3) return null;
                const [ddStr, mmStr, aaStr] = partes;
                const dd = parseInt(ddStr, 10);
                const mm = parseInt(mmStr, 10);
                const aa = parseInt(aaStr, 10);
                if (!dd || !mm || isNaN(aa)) return null;
                const year = aaStr.length <= 2 ? (2000 + aa) : aa;
                const d = new Date(year, mm - 1, dd);
                if (isNaN(d.getTime())) return null;
                d.setHours(0,0,0,0);
                return d;
            }
            // ISO u otros
            const d = new Date(s);
            if (isNaN(d.getTime())) return null;
            d.setHours(0,0,0,0);
            return d;
        }

        function clasificarPrueba(reg) {
            const periodo = (reg.periodo || '').toString().trim().toUpperCase();
            // POST-TRABAJO y REPARACION son solo hist√≥rico: no deben definir ni usar proxima.
            if (periodo && periodo !== 'ANUAL') return { estado: 'SIN_FECHA', proxima: null };

            let proxima = parseProxima(reg.proxima || '');
            // Si no hay 'proxima' pero es ANUAL, intentar derivarla de fechaRealizacion + 12 meses
            if (!proxima) {
                const fr = parseFechaRealizacion(reg.fechaRealizacion || reg.fechaPrueba || '');
                // Backward compat: sin periodo => tratar como ANUAL
                if ((periodo === 'ANUAL' || !periodo) && fr) {
                    const d = new Date(fr);
                    d.setFullYear(d.getFullYear() + 1);
                    d.setHours(0,0,0,0);
                    if (!isNaN(d.getTime())) proxima = d;
                }
            }
            if (!proxima) return { estado: 'SIN_FECHA', proxima: null };
            const hoy = hoySinHora();
            if (proxima < hoy) return { estado: 'VENCIDA', proxima };
            return { estado: 'VIGENTE', proxima };
        }

        function normEquipoKey(v) {
            let t = (v || '').toString();
            t = t.replace(/\u00A0/g, ' ');
            t = t.replace(/[\s\u200B-\u200D\uFEFF]+/g, '');
            t = t.trim().toUpperCase();
            return t;
        }

        function render() {
            const filtro = (inputBuscar?.value || '').toLowerCase().trim();

            tbodyListado.innerHTML = '';
            if (msgListado) msgListado.style.display = 'none';
            if (tbodyResumen) tbodyResumen.innerHTML = '';
            if (msgResumen) msgResumen.style.display = 'none';

            if (!pruebas.length && (!equiposInventario || !equiposInventario.size)) {
                if (msgListado) msgListado.style.display = 'block';
                if (msgResumen) msgResumen.style.display = 'block';
                if (lblPend) lblPend.textContent = '0 por realizar';
                if (lblVenc) lblVenc.textContent = '0 vencidas';
                if (lblHist) lblHist.textContent = '0 en hist√≥rico';
                if (lblResVig) lblResVig.textContent = '0';
                if (lblResVenc) lblResVenc.textContent = '0';
                if (lblResSin) lblResSin.textContent = '0';
                if (lblResPorCad) lblResPorCad.textContent = '0';
                if (lblResCaducadas) lblResCaducadas.textContent = '0';
                return;
            }

            const hoy = hoySinHora();

            const enriquecidas = pruebas.map(reg => {
                const clasif = clasificarPrueba(reg);
                const fechaReal = parseFechaRealizacion(reg.fechaRealizacion || '') || hoySinHora();
                return { ...reg, _clasif: clasif, _fechaRealDate: fechaReal };
            });

            const porRealizar = [];
            const historico = [...enriquecidas];
            const totalHistorico = historico.length;

            enriquecidas.forEach(reg => {
                if (reg._clasif.estado === 'VIGENTE' || reg._clasif.estado === 'VENCIDA') {
                    porRealizar.push(reg);
                }
            });

            // Construir referencia: √∫ltima ANUAL por equipo
            const anualPorEquipo = new Map();
            enriquecidas.forEach(reg => {
                const eq = normEquipoKey(reg.equipo);
                if (!eq) return;
                const periodo = (reg.periodo || '').toString().trim().toUpperCase();
                // Backward compat: registros sin periodo se consideran ANUAL
                if (periodo && periodo !== 'ANUAL') return;
                const actual = anualPorEquipo.get(eq);
                if (!actual || reg._fechaRealDate.getTime() > actual._fechaRealDate.getTime()) {
                    anualPorEquipo.set(eq, reg);
                }
            });

            // Visualizador de cobertura por equipo (inventario como base):
            // 100%: ANUAL + VT/PT/MT + UTT por equipo (se ignoran Post-trabajo/Reparaci√≥n para completar cobertura)
            try {
                const lbl100 = document.getElementById('pruebas-equipos-100');
                const lblPar = document.getElementById('pruebas-equipos-parcial');
                const lblSin = document.getElementById('pruebas-equipos-sin');
                const lblSinWip = document.getElementById('pruebas-equipos-sin-wip');
                const lblTot = document.getElementById('pruebas-equipos-total');

                const equiposBase = (equiposInventario && equiposInventario.size)
                    ? Array.from(equiposInventario)
                    : Array.from(new Set([...(pruebas || []).map(r => normEquipoKey(r && r.equipo ? String(r.equipo) : '')).filter(Boolean)]));

                const equiposConAlgo = new Set();
                const equiposConVpm = new Set();
                const equiposConUtt = new Set();
                (pruebas || []).forEach(r => {
                    const eq = normEquipoKey((r && r.equipo) ? String(r.equipo) : '');
                    if (eq) equiposConAlgo.add(eq);

                    const periodo = (r && r.periodo) ? String(r.periodo).trim().toUpperCase() : '';
                    const esHistorico = (periodo === 'POST-TRABAJO' || periodo === 'REPARACION');
                    if (esHistorico) return;

                    const p = ((r && (r.prueba || r.pruebaTipo)) ? String(r.prueba || r.pruebaTipo) : '').toUpperCase();
                    if (p.includes('UTT')) equiposConUtt.add(eq);
                    if (p.includes('VT') || p.includes('PT') || p.includes('MT')) equiposConVpm.add(eq);
                });
                const equiposConAnual = new Set(Array.from(anualPorEquipo.keys()));

                let c100 = 0;
                let cPar = 0;
                let cSin = 0;
                let cSinWip = 0;

                window._equiposCobertura = window._equiposCobertura || {};

                equiposBase.forEach(eq => {
                    const hasAny = equiposConAlgo.has(eq);
                    const hasAnual = equiposConAnual.has(eq);
                    const hasVpm = equiposConVpm.has(eq);
                    const hasUtt = equiposConUtt.has(eq);
                    const is100 = !!(hasAnual && hasVpm && hasUtt);
                    const cat = (!hasAny) ? 'sin' : (is100 ? '100' : 'parcial');
                    window._equiposCobertura[eq] = { cat, hasAny, hasAnual, hasVpm, hasUtt };
                    if (cat === '100') c100 += 1;
                    else if (cat === 'parcial') cPar += 1;
                    else {
                        cSin += 1;
                        const edo = (edoPorEquipoInv && edoPorEquipoInv[eq]) ? String(edoPorEquipoInv[eq]).toUpperCase() : '';
                        if (edo === 'WIP') cSinWip += 1;
                    }
                });

                if (lbl100) lbl100.textContent = String(c100);
                if (lblPar) lblPar.textContent = String(cPar);
                if (lblSin) lblSin.textContent = String(cSin);
                if (lblSinWip) lblSinWip.textContent = String(cSinWip);
                if (lblTot) lblTot.textContent = String(equiposBase.length);
            } catch {}

            // Construir referencia de categor√≠a por registro (LT, VT/PT/MT, UTT)
            function categoriaPrueba(reg) {
                const p = ((reg.prueba || reg.pruebaTipo || '') + '').toUpperCase();
                if (!p) return null;
                if (p.includes('UTT')) return 'utt';
                if (p.includes('LT')) return 'lt';
                if (p.includes('VT') || p.includes('PT') || p.includes('MT')) return 'vpm';
                return null;
            }

            // Inicializar contadores
            const cont = {
                lt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                vpm: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                utt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
            };

            let _lastImportBatchId = '';
            try { _lastImportBatchId = String(localStorage.getItem('pct_pruebas_last_import_batch_id') || ''); } catch {}

            function isScopedIndicator(reg) {
                if (!_lastImportBatchId) return true;
                const cat = categoriaPrueba(reg);
                if (cat === 'lt') return true;
                if (cat === 'vpm' || cat === 'utt') {
                    const bid = (reg && reg.importBatchId) ? String(reg.importBatchId) : '';
                    return bid === _lastImportBatchId;
                }
                return false;
            }

            // Post-trabajo y Reparaci√≥n distribuidos por buckets seg√∫n fecha de realizaci√≥n (antig√ºedad)
            const pt = {
                lt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                vpm: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                utt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
            };
            const rep = {
                lt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                vpm: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                utt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
            };

            // Clasificar por buckets por REGISTRO (prueba), no por equipo
            (Array.isArray(historico) ? historico : []).forEach(reg => {
                const periodo = (reg.periodo || '').toString().trim().toUpperCase();
                // Solo ANUAL define pr√≥xima (y por tanto, vigencia)
                if (periodo && periodo !== 'ANUAL') return;
                const cat = categoriaPrueba(reg);
                if (!cat) return;
                if (!isScopedIndicator(reg)) return;
                let prox = parseProxima(reg.proxima || '');
                // Si no hay 'proxima' pero es ANUAL, intentar derivarla de fechaRealizacion + 12 meses
                if (!prox) {
                    const fr = parseFechaRealizacion(reg.fechaRealizacion || reg.fechaPrueba || '');
                    // Backward compat: sin periodo => tratar como ANUAL
                    if ((periodo === 'ANUAL' || !periodo) && fr) {
                        const d = new Date(fr);
                        d.setFullYear(d.getFullYear() + 1);
                        d.setHours(0,0,0,0);
                        if (!isNaN(d.getTime())) prox = d;
                    }
                }
                if (!prox) return;
                const dias = Math.round((prox.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
                if (isNaN(dias)) return;
                if (dias <= 0) { cont[cat].d0 += 1; return; }
                if (dias > 60) cont[cat].gt60 += 1;
                else if (dias >= 31) cont[cat].d60 += 1;
                else if (dias >= 16) cont[cat].d30 += 1;
                else if (dias >= 1) cont[cat].d15 += 1; // 1..15
            });

            // Contar Post-trabajo y Reparaci√≥n por categor√≠a y bucket (seg√∫n fecha de realizaci√≥n)
            (Array.isArray(historico) ? historico : []).forEach(reg => {
                const periodo = (reg.periodo || '').toString().trim().toUpperCase();
                const cat = categoriaPrueba(reg);
                if (!cat) return;
                if (periodo !== 'POST-TRABAJO' && periodo !== 'REPARACION') return;
                const fr = reg._fechaRealDate instanceof Date ? reg._fechaRealDate : parseFechaRealizacion(reg.fechaRealizacion || '');
                if (!fr) return;
                const dAnt = Math.max(0, Math.round((hoy.getTime() - fr.getTime()) / (1000 * 60 * 60 * 24)));
                const bucket = (dAnt === 0) ? 'd0' : (dAnt >= 1 && dAnt <= 15) ? 'd15' : (dAnt >= 16 && dAnt <= 30) ? 'd30' : (dAnt >= 31 && dAnt <= 60) ? 'd60' : 'gt60';
                if (periodo === 'POST-TRABAJO') pt[cat][bucket] += 1;
                else if (periodo === 'REPARACION') rep[cat][bucket] += 1;
            });

            // Pintar tabla informativa (solo conteo ANUAL por rango)
            try {
                if (!_csvPreviewActive) {
                    if (inf.lt.gt60) inf.lt.gt60.textContent = String(cont.lt.gt60);
                    if (inf.lt.d60)  inf.lt.d60.textContent  = String(cont.lt.d60);
                    if (inf.lt.d30)  inf.lt.d30.textContent  = String(cont.lt.d30);
                    if (inf.lt.d15)  inf.lt.d15.textContent  = String(cont.lt.d15);
                    if (inf.lt.d0)   inf.lt.d0.textContent   = String(cont.lt.d0);

                    if (inf.vpm.gt60) inf.vpm.gt60.textContent = String(cont.vpm.gt60);
                    if (inf.vpm.d60)  inf.vpm.d60.textContent  = String(cont.vpm.d60);
                    if (inf.vpm.d30)  inf.vpm.d30.textContent  = String(cont.vpm.d30);
                    if (inf.vpm.d15)  inf.vpm.d15.textContent  = String(cont.vpm.d15);
                    if (inf.vpm.d0)   inf.vpm.d0.textContent   = String(cont.vpm.d0);

                    if (inf.utt.gt60) inf.utt.gt60.textContent = String(cont.utt.gt60);
                    if (inf.utt.d60)  inf.utt.d60.textContent  = String(cont.utt.d60);
                    if (inf.utt.d30)  inf.utt.d30.textContent  = String(cont.utt.d30);
                    if (inf.utt.d15)  inf.utt.d15.textContent  = String(cont.utt.d15);
                    if (inf.utt.d0)   inf.utt.d0.textContent   = String(cont.utt.d0);
                }
            } catch {}

            // Resumen por equipo (√∫ltima ANUAL) incluyendo equipos sin ANUAL (desde inventario)
            if (tbodyResumen && lblResVig && lblResVenc && lblResSin) {
                const listaEquiposBase = equiposInventario && equiposInventario.size
                    ? Array.from(equiposInventario)
                    : Array.from(new Set([...(pruebas || []).map(r => normEquipoKey(r && r.equipo ? String(r.equipo) : '')).filter(Boolean)]));

                if (!listaEquiposBase.length && msgResumen) {
                    msgResumen.style.display = 'block';
                }

                let cntEquiposVig = 0;
                let cntEquiposVenc = 0;
                let cntEquiposSin = 0;
                let cntEquiposPorCaducar = 0;

                const listaEquiposFiltrada = listaEquiposBase.filter(eq => {
                    if (!filtroCobertura) return true;
                    const cov = (window._equiposCobertura && window._equiposCobertura[eq]) ? window._equiposCobertura[eq] : null;
                    const cat = cov ? cov.cat : 'sin';
                    return cat === filtroCobertura;
                });

                listaEquiposFiltrada.sort((a, b) => a.localeCompare(b)).forEach(eq => {
                    const reg = anualPorEquipo.get(eq) || null;
                    const estado = reg ? reg._clasif.estado : 'SIN_PRUEBA';

                    if (estado === 'VIGENTE') {
                        cntEquiposVig += 1;
                        const dProx = parseProxima(reg ? (reg.proxima || '') : '');
                        if (dProx) {
                            const dias = Math.round((dProx.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
                            if (dias >= 0 && dias <= 60) cntEquiposPorCaducar += 1;
                        }
                    } else if (estado === 'VENCIDA') {
                        cntEquiposVenc += 1;
                    } else {
                        cntEquiposSin += 1;
                    }

                    const fila = document.createElement('tr');
                    const proximaStr = reg ? (reg.proxima || '') : '';
                    const fechaReal = reg ? (reg.fechaRealizacion || '') : '';
                    const tecnico = reg ? (reg.tecnico || '') : '';
                    const noRep = reg ? (reg.noReporte || '') : '';
                    const desc = reg && reg.descripcion
                        ? reg.descripcion
                        : (descripcionPorEquipoInv[eq] || '');

                    const badge =
                        estado === 'VIGENTE'
                            ? '<span style="padding:0.1rem 0.5rem; border-radius:999px; background:#dcfce7; color:#166534; font-size:0.75rem;">Vigente</span>'
                            : estado === 'VENCIDA'
                                ? '<span style="padding:0.1rem 0.5rem; border-radius:999px; background:#fee2e2; color:#b91c1c; font-size:0.75rem;">Vencida</span>'
                                : '<span style="padding:0.1rem 0.5rem; border-radius:999px; background:#e5e7eb; color:#374151; font-size:0.75rem;">Sin prueba</span>';

                    fila.innerHTML = `
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${eq}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${desc}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${fechaReal}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${proximaStr}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${tecnico}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${noRep}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${badge}</td>
                    `;
                    tbodyResumen.appendChild(fila);
                });

                lblResVig.textContent = String(cntEquiposVig);
                lblResVenc.textContent = String(cntEquiposVenc);
                lblResSin.textContent = String(cntEquiposSin);
                if (lblResPorCad) lblResPorCad.textContent = String(cntEquiposPorCaducar);
                if (lblResCaducadas) lblResCaducadas.textContent = String(cntEquiposVenc);
            }

            // Ordenar priorizando pr√≥ximas a vencer (VIGENTE con d√≠as >= 0, ascendente) POR PRUEBA,
            // luego vencidas, luego sin fecha, y en cada grupo por fecha de realizaci√≥n desc.
            function diasHastaProxima(reg) {
                const clasif = clasificarPrueba(reg);
                if (!clasif || !clasif.proxima) return null;
                const hoy0 = hoySinHora();
                const diffMs = clasif.proxima.getTime() - hoy0.getTime();
                let dias = Math.round(diffMs / (1000 * 60 * 60 * 24));
                return dias;
            }

            const listaOrdenada = [...historico].sort((a, b) => {
                const da = diasHastaProxima(a);
                const db = diasHastaProxima(b);
                const ea = (clasificarPrueba(a)?.estado) || 'SIN_FECHA';
                const eb = (clasificarPrueba(b)?.estado) || 'SIN_FECHA';

                const cat = (regEstado, dias) => {
                    if (regEstado === 'VIGENTE' && dias !== null && dias >= 0) return 0; // pr√≥ximas a vencer
                    if (regEstado === 'VENCIDA') return 1; // vencidas
                    return 2; // sin fecha u otros
                };

                const ca = cat(ea, da);
                const cb = cat(eb, db);
                if (ca !== cb) return ca - cb;

                if (ca === 0) {
                    // Ambos en pr√≥ximas a vencer: menor d√≠as primero
                    if (da !== db) return (da ?? Number.POSITIVE_INFINITY) - (db ?? Number.POSITIVE_INFINITY);
                }

                // Mismo grupo: m√°s reciente primero
                return b._fechaRealDate.getTime() - a._fechaRealDate.getTime();
            });

            let cntPend = 0;
            let cntVenc = 0;
            let cntHist = 0;

            // Chips: contar PRUEBAS (no equipos)
            let cntChipGT60 = 0; // > 60
            let cntChip60 = 0;   // 60‚Äì31
            let cntChip30 = 0;   // 30‚Äì16
            let cntChip15 = 0;   // 15‚Äì1
            let cntChip0 = 0;    // 0 (vencidas)

            const filasVisibles = [];

            if (filtroCobertura === 'sin') {
                const histByEq = {};
                try {
                    (pruebas || []).forEach(r => {
                        const eqK = normEquipoKey(r && r.equipo ? String(r.equipo) : '');
                        if (!eqK) return;
                        const per = (r && r.periodo) ? String(r.periodo).trim().toUpperCase() : '';
                        if (per !== 'POST-TRABAJO' && per !== 'REPARACION') return;
                        histByEq[eqK] = histByEq[eqK] || { pt: 0, rep: 0 };
                        if (per === 'POST-TRABAJO') histByEq[eqK].pt += 1;
                        else if (per === 'REPARACION') histByEq[eqK].rep += 1;
                    });
                } catch {}

                let equiposSin = [];
                try {
                    const base = (equiposInventario && equiposInventario.size)
                        ? Array.from(equiposInventario)
                        : Object.keys(window._equiposCobertura || {});
                    equiposSin = base
                        .map(eq => normEquipoKey(eq))
                        .filter(Boolean)
                        .filter(eqK => {
                            const cov = (window._equiposCobertura && window._equiposCobertura[eqK]) ? window._equiposCobertura[eqK] : null;
                            return cov && cov.cat === 'sin';
                        });
                } catch { equiposSin = []; }

                const vistos = new Set();
                equiposSin
                    .filter(eqK => {
                        if (vistos.has(eqK)) return false;
                        vistos.add(eqK);
                        return true;
                    })
                    .sort((a, b) => a.localeCompare(b))
                    .forEach(eqK => {
                        const desc = (descripcionPorEquipoInv && descripcionPorEquipoInv[eqK]) ? String(descripcionPorEquipoInv[eqK]) : '';
                        const prod = (productoPorEquipoInv && productoPorEquipoInv[eqK]) ? String(productoPorEquipoInv[eqK]) : '';
                        const serial = (serialPorEquipoInv && serialPorEquipoInv[eqK]) ? String(serialPorEquipoInv[eqK]) : '';
                        const textoBuscarEq = `${eqK} ${serial} ${prod} ${desc}`.toLowerCase();
                        if (filtro && !textoBuscarEq.includes(filtro)) return;

                        const edo = (edoPorEquipoInv && edoPorEquipoInv[eqK]) ? String(edoPorEquipoInv[eqK]).toUpperCase() : '';
                        const isWip = (edo === 'WIP');
                        const hb = histByEq[eqK] || { pt: 0, rep: 0 };
                        const hasHist = !!((hb.pt || 0) > 0 || (hb.rep || 0) > 0);

                        const idx = filasVisibles.length;
                        filasVisibles.push({
                            id: '',
                            equipo: eqK,
                            producto: prod,
                            descripcion: desc,
                            periodo: '',
                            fechaRealizacion: '',
                            proxima: '',
                            prueba: '',
                            area: '',
                            noReporte: '',
                            resultado: '',
                            emisor: '',
                            tecnico: '',
                            _placeholder: true,
                            _wip: isWip,
                            _histPt: hb.pt || 0,
                            _histRep: hb.rep || 0,
                        });

                        const fila = document.createElement('tr');
                        const tdSelect = permitirEliminar
                            ? `<td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"><input type="checkbox" class="prueba-select" data-idx="${idx}"></td>`
                            : '';
                        const badgeSin = '<span style="padding:0.1rem 0.5rem; border-radius:999px; background:#e5e7eb; color:#374151; font-size:0.75rem;">Sin prueba</span>';
                        const badgeWip = isWip
                            ? '<span style="margin-left:0.35rem; padding:0.1rem 0.5rem; border-radius:999px; background:#fef3c7; color:#92400e; font-size:0.75rem;">WIP</span>'
                            : '';
                        const histParts = [];
                        if ((hb.pt || 0) > 0) histParts.push(`Post-trab: ${hb.pt}`);
                        if ((hb.rep || 0) > 0) histParts.push(`Reparaci√≥n: ${hb.rep}`);
                        const badgeHist = hasHist
                            ? `<span title="Registros hist√≥ricos existentes" style="margin-left:0.35rem; padding:0.1rem 0.5rem; border-radius:999px; background:#e0f2fe; color:#075985; font-size:0.75rem;">Hist√≥rico (${histParts.join(', ')})</span>`
                            : '';
                        const badgeEstado = `${badgeSin}${badgeWip}${badgeHist}`;
                        fila.innerHTML = `
                            ${tdSelect}
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${badgeEstado}</td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${eqK}</td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${prod}</td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${desc}</td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"></td>
                            <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"></td>
                        `;

                        fila.style.cursor = 'pointer';
                        fila.addEventListener('dblclick', (e) => {
                            try {
                                const target = e && e.target;
                                if (target && target.closest && target.closest('input, select, button, a, label')) return;
                            } catch {}
                            try {
                                const params = new URLSearchParams();
                                if (eqK) params.set('equipo', eqK);
                                if (prod) params.set('producto', prod);
                                if (desc) params.set('descripcion', desc);
                                params.set('periodo', 'ANUAL');
                                window.open(`pruebas.html?${params.toString()}`, '_blank');
                            } catch {}
                        });

                        tbodyListado.appendChild(fila);
                        cntHist += 1;
                    });

                if (msgListado) msgListado.style.display = (cntHist ? 'none' : 'block');
                if (!_csvPreviewActive) {
                    if (lblPend) lblPend.textContent = `${cntPend} por realizar`;
                    if (lblVenc) lblVenc.textContent = `${cntVenc} vencida${cntVenc === 1 ? '' : 's'}`;
                    if (lblHist) {
                        if (typeof _totalServer === 'number') lblHist.textContent = `Mostrando ${totalHistorico} de ${_totalServer}`;
                        else lblHist.textContent = `${totalHistorico} en hist√≥rico`;
                    }
                }
                tbodyListado._filasVisibles = filasVisibles;
                return;
            }

            listaOrdenada.forEach(reg => {
                const eqK = normEquipoKey(reg.equipo);
                const serialInv = (serialPorEquipoInv && eqK && serialPorEquipoInv[eqK]) ? String(serialPorEquipoInv[eqK]) : '';
                const textoBuscar = `${reg.equipo || ''} ${serialInv} ${reg.producto || ''} ${reg.descripcion || ''} ${reg.tecnico || ''} ${reg.noReporte || ''}`.toLowerCase();
                if (filtro && !textoBuscar.includes(filtro)) return;

                // Filtro por cobertura (100/parcial/sin) aplicado al listado grande por equipo
                if (filtroCobertura) {
                    // Nota: la categor√≠a 'sin' significa equipos del inventario sin NING√öN registro.
                    // Por definici√≥n, no existen filas en el listado grande para esos equipos.
                    if (filtroCobertura === 'sin') return;
                    const eqK = normEquipoKey(reg.equipo);
                    const cov = (window._equiposCobertura && window._equiposCobertura[eqK]) ? window._equiposCobertura[eqK] : null;
                    if (!cov) return;
                    if (cov.cat !== filtroCobertura) return;
                }

                const clasifOriginal = clasificarPrueba(reg);
                const periodoReg = (reg.periodo || '').toString().trim().toUpperCase();
                const esAnualReg = (periodoReg === 'ANUAL' || !periodoReg);
                const esHistoricoReg = (periodoReg === 'POST-TRABAJO' || periodoReg === 'REPARACION');

                // Post-trabajo y Reparaci√≥n son hist√≥ricos: no muestran pr√≥xima ni contador, y no heredan vigencia.
                const estado = esHistoricoReg
                    ? 'HISTORICO'
                    : (clasifOriginal ? (clasifOriginal.estado || 'SIN_FECHA') : 'SIN_FECHA');
                const proximaBase = esHistoricoReg
                    ? null
                    : (clasifOriginal && clasifOriginal.proxima) ? clasifOriginal.proxima : null;
                const proximaStr = proximaBase ? formateaDDMMAA(proximaBase) : '';

                const fila = document.createElement('tr');

                if (estado === 'VENCIDA') {
                    fila.style.background = '#fef2f2';
                    fila.style.color = '#b91c1c';
                }

                // C√°lculo de d√≠as restantes hasta la pr√≥xima prueba
                let diasParaProxima = '';
                let diasNum = null;
                if (proximaBase) {
                    const hoy = hoySinHora();
                    const diffMs = proximaBase.getTime() - hoy.getTime();
                    let dias = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    if (dias < 0) dias = 0; // para vencidas mostramos 0
                    diasNum = dias;
                    diasParaProxima = String(dias);
                }

                // Contar alertas por PRUEBA (no por equipo), solo vigentes; rangos: 60‚Äì31, 30‚Äì16, 15‚Äì1
                // esAnualReg ya calculado arriba
                const scopedForIndicators = isScopedIndicator(reg);
                if (scopedForIndicators && esAnualReg && estado === 'VIGENTE' && diasNum !== null && diasNum >= 1) {
                    if (diasNum >= 31 && diasNum <= 60) {
                        cntChip60 += 1;
                    } else if (diasNum >= 16 && diasNum <= 30) {
                        cntChip30 += 1;
                    } else if (diasNum >= 1 && diasNum <= 15) {
                        cntChip15 += 1;
                    }
                }
                if (scopedForIndicators && esAnualReg && estado === 'VIGENTE' && diasNum !== null && diasNum > 60) {
                    cntChipGT60 += 1;
                }
                if (scopedForIndicators && esAnualReg && estado === 'VENCIDA') {
                    cntChip0 += 1;
                }

                // Aplicar filtro por periodo si est√° activo
                const periodoNorm = (reg.periodo || '').toString().trim().toUpperCase() || 'ANUAL';
                if (filtroPeriodo && periodoNorm !== filtroPeriodo) return;

                // Aplicar filtro por rango si est√° activo (solo vigentes), rangos: 60‚Äì31, 30‚Äì16, 15‚Äì1
                // Importante: SOLO filtra ANUAL; si el filtroPeriodo fuerza POST-TRABAJO o REPARACION, no aplica rangos
                if (filtroRango && esAnualReg && (!filtroPeriodo || filtroPeriodo === 'ANUAL')) {
                    if (filtroRango === '0') {
                        if (estado !== 'VENCIDA') return;
                    } else if (filtroRango === 'gt60') {
                        if (estado !== 'VIGENTE' || diasNum === null || !(diasNum > 60)) return;
                    } else {
                        if (estado !== 'VIGENTE' || diasNum === null || diasNum < 1) return;
                        if (filtroRango === '60' && !(diasNum >= 31 && diasNum <= 60)) return;
                        if (filtroRango === '30' && !(diasNum >= 16 && diasNum <= 30)) return;
                        if (filtroRango === '15' && !(diasNum >= 1 && diasNum <= 15)) return;
                    }
                }

                // Contadores alineados al dashboard (despu√©s de calcular diasNum):
                // - "Por realizar" = pruebas ANUALES vigentes cuyo dProx est√° entre 0 y 60 d√≠as (suma de 60‚Äì30, 30‚Äì15, 15‚Äì0)
                // - "Vencidas" = pruebas ANUALES con pr√≥xima ya pasada (estado VENCIDA)
                if (scopedForIndicators && esAnualReg && estado === 'VIGENTE' && diasNum !== null && diasNum >= 0 && diasNum <= 60) {
                    cntPend += 1;
                }
                if (scopedForIndicators && esAnualReg && estado === 'VENCIDA') {
                    cntVenc += 1;
                }

                // Badge visual seg√∫n estado, d√≠as restantes y resultado (solo presentaci√≥n)
                const resultadoStr = (reg.resultado || '').toString().trim().toUpperCase();
                let badgeEstado;

                if (estado === 'HISTORICO') {
                    badgeEstado = '<span title="Registro hist√≥rico (Post-trabajo/Reparaci√≥n): no define pr√≥xima prueba" style="padding:0.1rem 0.5rem; border-radius:999px; background:#e5e7eb; color:#374151; font-size:0.75rem;">Hist√≥rico</span>';
                // Prioridad visual: resultado RECHAZADA => Inoperable
                } else if (resultadoStr === 'RECHAZADA') {
                    badgeEstado = '<span title="Resultado RECHAZADA: equipo inoperable" style="padding:0.1rem 0.5rem; border-radius:999px; background:#fee2e2; color:#b91c1c; font-size:0.75rem;">Inoperable</span>';
                } else if (estado === 'VENCIDA') {
                    badgeEstado = '<span title="Prueba vencida: la pr√≥xima fecha ya pas√≥" style="padding:0.1rem 0.5rem; border-radius:999px; background:#fee2e2; color:#b91c1c; font-size:0.75rem;">Vencida</span>';
                } else if (estado !== 'VIGENTE') {
                    const etiqueta = esAnualReg ? 'Sin fecha' : 'N/A';
                    badgeEstado = `<span title="Sin informaci√≥n de pr√≥xima prueba" style="padding:0.1rem 0.5rem; border-radius:999px; background:#e5e7eb; color:#374151; font-size:0.75rem;">${etiqueta}</span>`;
                } else {
                    // VIGENTE: ajustar solo apariencia por rango de d√≠as
                    if (diasNum === null) {
                        badgeEstado = '<span title="Prueba vigente" style="padding:0.1rem 0.5rem; border-radius:999px; background:#dcfce7; color:#166534; font-size:0.75rem;">Vigente</span>';
                    } else if (diasNum >= 30 && diasNum <= 60) {
                        badgeEstado = '<span title="Pr√≥ximo a caducar (60 a 30 d√≠as para la pr√≥xima prueba)" style="padding:0.1rem 0.5rem; border-radius:999px; background:#eff6ff; color:#1d4ed8; font-size:0.75rem;">Pr√≥ximo a caducar</span>';
                    } else if (diasNum >= 15 && diasNum < 30) {
                        badgeEstado = '<span title="Pr√≥ximo a caducar (30 a 15 d√≠as para la pr√≥xima prueba)" style="padding:0.1rem 0.5rem; border-radius:999px; background:#fef3c7; color:#b45309; font-size:0.75rem;">Pr√≥ximo a caducar</span>';
                    } else if (diasNum >= 0 && diasNum < 15) {
                        badgeEstado = '<span title="Pr√≥ximo a caducar (menos de 15 d√≠as para la pr√≥xima prueba)" style="padding:0.1rem 0.5rem; border-radius:999px; background:#fee2e2; color:#b91c1c; font-size:0.75rem;">Pr√≥ximo a caducar</span>';
                    } else {
                        // Vigente pero fuera de esos rangos (m√°s de 60 d√≠as, etc.)
                        badgeEstado = '<span title="Prueba vigente" style="padding:0.1rem 0.5rem; border-radius:999px; background:#dcfce7; color:#166534; font-size:0.75rem;">Vigente</span>';
                    }
                }

                const idx = filasVisibles.length;
                filasVisibles.push(reg);

                const periodoActual = (reg.periodo || '').toString().trim().toUpperCase();
                const esAdmin = !!window.isAdmin;
                const periodoTexto = periodoActual || '';

                const esEditable = !!(window.isAdmin || window.isDirector || window.isSupervisor);
                const esAdminOnly = !!window.isAdmin;
                const celdaPeriodo = esEditable
                    ? `<select class="pl-periodo" data-id="${reg.id || ''}">
                            <option value=""></option>
                            <option value="ANUAL" ${periodoActual === 'ANUAL' || !periodoActual ? 'selected' : ''}>Anual</option>
                            <option value="POST-TRABAJO" ${periodoActual === 'POST-TRABAJO' ? 'selected' : ''}>Post-trabajo</option>
                            <option value="REPARACION" ${periodoActual === 'REPARACION' ? 'selected' : ''}>Reparaci√≥n</option>
                       </select>`
                    : periodoTexto;

                const textoPrueba = (reg.prueba || reg.pruebaTipo || '').toString();
                const celdaPrueba = esEditable
                    ? `<input type="text" class="pl-prueba" data-id="${reg.id || ''}" value="${textoPrueba.replace(/"/g, '&quot;')}">`
                    : textoPrueba;

                const textoNoRep = (reg.noReporte || '').toString();
                const celdaNoRep = esEditable
                    ? `<input type="text" class="pl-norep" required data-id="${reg.id || ''}" data-prev="${textoNoRep.replace(/"/g, '&quot;')}" value="${textoNoRep.replace(/"/g, '&quot;')}" style="direction:rtl; text-align:left;">`
                    : textoNoRep;

                const resultadoActual = (reg.resultado || '').toString();
                const celdaResultado = esEditable
                    ? `<select class="pl-resultado" data-id="${reg.id || ''}">
                            <option value=""></option>
                            <option value="ACEPTADA" ${resultadoActual === 'ACEPTADA' ? 'selected' : ''}>ACEPTADA</option>
                            <option value="RECHAZADA" ${resultadoActual === 'RECHAZADA' ? 'selected' : ''}>RECHAZADA</option>
                       </select>`
                    : resultadoActual;

                const celdaEmisor = esAdminOnly
                    ? `<input type="text" class="pl-emisor" data-id="${reg.id || ''}" value="${(reg.emisor || '').toString().replace(/"/g, '&quot;')}">`
                    : (reg.emisor || '');

                const celdaTecnico = esAdminOnly
                    ? `<input type="text" class="pl-tecnico" data-id="${reg.id || ''}" value="${(reg.tecnico || '').toString().replace(/"/g, '&quot;')}">`
                    : (reg.tecnico || '');
                
                const tdSelect = permitirEliminar
                    ? `<td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;"><input type=\"checkbox\" class=\"prueba-select\" data-idx=\"${idx}\"></td>`
                    : '';

                fila.innerHTML = `
                    ${tdSelect}
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${reg.fechaRealizacion || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${proximaStr}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${celdaPeriodo}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${badgeEstado}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${diasParaProxima}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.equipo || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.producto || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.descripcion || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${celdaPrueba}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.area || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${celdaNoRep}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${celdaResultado}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${celdaEmisor}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${celdaTecnico}</td>
                `;

                fila.style.cursor = 'pointer';
                // Evitar que interacciones con controles activen el toggle de fila
                fila.querySelectorAll('input, select, button, a, label').forEach(el => {
                    el.addEventListener('click', (e) => e.stopPropagation());
                    el.addEventListener('mousedown', (e) => e.stopPropagation());
                });
                fila.addEventListener('click', () => {
                    toggleDetalleInline(fila, reg);
                });
                fila.addEventListener('dblclick', (e) => {
                    try {
                        const target = e && e.target;
                        if (target && target.closest && target.closest('input, select, button, a, label')) return;
                    } catch {}
                    try { e.preventDefault(); } catch {}
                    try { e.stopPropagation(); } catch {}
                    try {
                        const tbody = fila.parentElement;
                        if (tbody) {
                            const abiertos = tbody.querySelectorAll('tr.pl-detalle-row');
                            abiertos.forEach(tr => tr.remove());
                            tbody.querySelectorAll('tr.pl-active').forEach(tr => tr.classList.remove('pl-active'));
                        }
                    } catch {}
                    abrirModalEdicion(reg);
                });

                tbodyListado.appendChild(fila);
                cntHist += 1;
            });

            if (!cntHist && msgListado) msgListado.style.display = 'block';
            if (!_csvPreviewActive) {
                if (lblPend) lblPend.textContent = `${cntPend} por realizar`;
                if (lblVenc) lblVenc.textContent = `${cntVenc} vencida${cntVenc === 1 ? '' : 's'}`;
                if (lblHist) {
                    if (typeof _totalServer === 'number') lblHist.textContent = `Mostrando ${totalHistorico} de ${_totalServer}`;
                    else lblHist.textContent = `${totalHistorico} en hist√≥rico`;
                }
            }

            try {
                if (!_csvPreviewActive) {
                    if (lblResumenParcial) {
                        if (typeof _totalServer === 'number' && _totalServer > 0) {
                            lblResumenParcial.textContent = `Resumen basado en ${totalHistorico} de ${_totalServer}`;
                        } else {
                            lblResumenParcial.textContent = `Resumen basado en ${totalHistorico}`;
                        }
                    }
                    const isPartial = (typeof _totalServer === 'number' && _totalServer > 0 && (pruebas && pruebas.length < _totalServer));
                    if (btnCompletarResumen) btnCompletarResumen.style.display = (isPartial && !_isLoadingAll) ? '' : 'none';
                }
            } catch {}

            try {
                const hasMore = !!_lastDoc && (typeof _totalServer !== 'number' || (pruebas && pruebas.length < _totalServer));
                if (bottomLoadWrap) bottomLoadWrap.style.display = hasMore ? 'flex' : 'none';
                if (btnMoreAllBottom) btnMoreAllBottom.disabled = !hasMore || _isLoadingAll || _isLoadingMore;
                if (btnMore200Bottom) btnMore200Bottom.disabled = !hasMore || _isLoadingAll || _isLoadingMore;
                if (btnMore500Bottom) btnMore500Bottom.disabled = !hasMore || _isLoadingAll || _isLoadingMore;
            } catch {}

            const lblAlertGT60 = document.getElementById('pruebas-alert-gt60');
            const lblAlert0 = document.getElementById('pruebas-alert-0');
            if (!_csvPreviewActive) {
                if (lblAlertGT60) lblAlertGT60.textContent = String(cntChipGT60);
                if (lblAlert60)   lblAlert60.textContent   = String(cntChip60);
                if (lblAlert30)   lblAlert30.textContent   = String(cntChip30);
                if (lblAlert15)   lblAlert15.textContent   = String(cntChip15);
                if (lblAlert0)    lblAlert0.textContent    = String(cntChip0);
            }

            // Reiniciar checkbox de selecci√≥n global
            if (chkSelectTodos) chkSelectTodos.checked = false;

            // Guardar referencia a filasVisibles en el tbody para exportaci√≥n
            tbodyListado._filasVisibles = filasVisibles;
        }

        if (inputBuscar) {
            inputBuscar.addEventListener('input', () => {
                render();
            });
        }

        function actualizarChipsUI() {
            [chipGT60, chip60, chip30, chip15, chip0].forEach(ch => ch && ch.classList.remove('chip-active'));
            if (filtroRango === 'gt60' && chipGT60) chipGT60.classList.add('chip-active');
            if (filtroRango === '60' && chip60) chip60.classList.add('chip-active');
            if (filtroRango === '30' && chip30) chip30.classList.add('chip-active');
            if (filtroRango === '15' && chip15) chip15.classList.add('chip-active');
            if (filtroRango === '0' && chip0) chip0.classList.add('chip-active');
        }

        function toggleFiltro(r) {
            filtroRango = (filtroRango === r) ? null : r;
            actualizarChipsUI();
            render();
        }

        if (chipGT60) chipGT60.addEventListener('click', () => toggleFiltro('gt60'));
        if (chip60)  chip60.addEventListener('click', () => toggleFiltro('60'));
        if (chip30) chip30.addEventListener('click', () => toggleFiltro('30'));
        if (chip15) chip15.addEventListener('click', () => toggleFiltro('15'));
        if (chip0)  chip0.addEventListener('click', () => toggleFiltro('0'));

        actualizarChipsUI();
        render();

        if (permitirEliminar && chkSelectTodos) {
            chkSelectTodos.addEventListener('change', () => {
                const checks = tbodyListado.querySelectorAll('.prueba-select');
                checks.forEach(chk => {
                    chk.checked = chkSelectTodos.checked;
                });
            });
        }

        function obtenerSeleccionadas() {
            const filas = tbodyListado._filasVisibles || [];
            const checks = tbodyListado.querySelectorAll('.prueba-select:checked');
            const seleccionadas = [];
            checks.forEach(chk => {
                const idx = parseInt(chk.getAttribute('data-idx') || '-1', 10);
                if (!isNaN(idx) && idx >= 0 && idx < filas.length) {
                    seleccionadas.push(filas[idx]);
                }
            });
            // Si no hay selecci√≥n expl√≠cita, usar todas las visibles
            return seleccionadas.length ? seleccionadas : filas;
        }

        async function actualizarCampoPrueba(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = (window.db || getFirestore());
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { prueba: nuevoValor, pruebaTipo: nuevoValor });

                // Actualizar en memoria
                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, prueba: nuevoValor, pruebaTipo: nuevoValor };
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar la prueba/calibraci√≥n para id ' + id, e);
                alert('No se pudo guardar el cambio de Prueba / Calib. Revisa la consola para m√°s detalles.');
            }
        }

        async function actualizarCampoNoReporte(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = (window.db || getFirestore());
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { noReporte: nuevoValor });

                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, noReporte: nuevoValor };
                    }
                    return reg;
                });

                try { localStorage.setItem(claveLocal, JSON.stringify(pruebas)); } catch {}
                try { window.pruebas = window.pctGetPruebas(); } catch {}
                try { buildExistingKeys(); } catch {}
            } catch (e) {
                console.error('No se pudo actualizar el No. reporte / cert. para id ' + id, e);
                alert('No se pudo guardar el cambio de No. reporte / cert. Revisa la consola para m√°s detalles.');
            }
        }

        async function actualizarCampoResultado(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = (window.db || getFirestore());
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { resultado: nuevoValor });

                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, resultado: nuevoValor };
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar el Resultado para id ' + id, e);
                alert('No se pudo guardar el cambio de Resultado. Revisa la consola para m√°s detalles.');
            }
        }

        async function actualizarCampoPeriodo(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc, deleteField } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = (window.db || getFirestore());
                const ref = doc(db, 'pruebas', id);

                const payload = { periodo: nuevoValor || '' };
                if (nuevoValor && nuevoValor !== 'ANUAL') {
                    payload.proxima = deleteField();
                }
                await updateDoc(ref, payload);

                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        const next = { ...reg, periodo: nuevoValor || '' };
                        if (nuevoValor && nuevoValor !== 'ANUAL') {
                            try { delete next.proxima; } catch {}
                        }
                        return next;
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar el Periodo para id ' + id, e);
                alert('No se pudo guardar el cambio de Periodo. Revisa la consola para m√°s detalles.');
            }
        }

        async function actualizarCampoEmisor(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = (window.db || getFirestore());
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { emisor: nuevoValor });

                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, emisor: nuevoValor };
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar el Emisor para id ' + id, e);
                alert('No se pudo guardar el cambio de Emisor. Revisa la consola para m√°s detalles.');
            }
        }

        async function actualizarCampoTecnico(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = (window.db || getFirestore());
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { tecnico: nuevoValor });

                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, tecnico: nuevoValor };
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar el T√©cnico para id ' + id, e);
                alert('No se pudo guardar el cambio de T√©cnico. Revisa la consola para m√°s detalles.');
            }
        }

        function exportarCsv() {
            const filas = obtenerSeleccionadas();
            if (!filas.length) {
                alert('No hay pruebas para exportar.');
                return;
            }

            const encabezados = [
                'FechaRealizacion',
                'Proxima',
                'Estado',
                'DiasParaProxima',
                'Equipo',
                'Producto',
                'Descripcion',
                'Prueba',
                'Area',
                'NoReporte',
                'Resultado',
                'Emisor',
                'Tecnico'
            ];

            function esc(val) {
                const s = String(val ?? '');
                if (/[",;\n]/.test(s)) {
                    return '"' + s.replace(/"/g, '""') + '"';
                }
                return s;
            }

            const hoy = new Date();
            const yyyy = hoy.getFullYear();
            const mm = String(hoy.getMonth() + 1).padStart(2, '0');
            const dd = String(hoy.getDate()).padStart(2, '0');

            const lineas = [];
            lineas.push(encabezados.join(','));

            filas.forEach(reg => {
                const clasif = clasificarPrueba(reg);
                let dias = '';
                if (clasif.proxima) {
                    const d0 = hoySinHora();
                    const diffMs = clasif.proxima.getTime() - d0.getTime();
                    let d = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    if (d < 0) d = 0;
                    dias = String(d);
                }

                const filaCsv = [
                    reg.fechaRealizacion || '',
                    reg.proxima || '',
                    clasif.estado || '',
                    dias,
                    reg.equipo || '',
                    reg.producto || '',
                    reg.descripcion || '',
                    reg.prueba || reg.pruebaTipo || '',
                    reg.area || '',
                    reg.noReporte || '',
                    reg.resultado || '',
                    reg.emisor || '',
                    reg.tecnico || ''
                ].map(esc).join(',');

                lineas.push(filaCsv);
            });

            const blob = new Blob([lineas.join('\n')], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pruebas_${yyyy}${mm}${dd}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        if (btnExportCsv) {
            btnExportCsv.addEventListener('click', exportarCsv);
        }

        async function eliminarSeleccionadas() {
            const filas = obtenerSeleccionadas();
            if (!filas.length) {
                alert('No hay pruebas seleccionadas para eliminar.');
                return;
            }

            const confirmar = window.confirm('Se eliminar√°n ' + filas.length + ' pruebas seleccionadas de Firestore. Esta acci√≥n no se puede deshacer. ¬øContinuar?');
            if (!confirmar) return;

            const idsAEliminar = new Set(
                filas
                    .map(reg => (reg && reg.id ? String(reg.id) : ''))
                    .filter(id => !!id)
            );

            if (!idsAEliminar.size) {
                alert('Las pruebas actuales no tienen identificador de Firestore, no se pueden eliminar remotamente.');
                return;
            }

            try {
                const { getFirestore, doc, deleteDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );

                const db = (window.db || getFirestore());

                for (const id of idsAEliminar) {
                    try {
                        const ref = doc(db, 'pruebas', id);
                        await deleteDoc(ref);
                    } catch (e) {
                        console.warn('No se pudo eliminar la prueba con id ' + id, e);
                    }
                }

                // Filtrar las pruebas en memoria y volver a renderizar
                pruebas = pruebas.filter(reg => !(reg && reg.id && idsAEliminar.has(String(reg.id))));
                render();
                alert('Eliminaci√≥n completada.');
            } catch (e) {
                console.error('Error al eliminar pruebas desde Firestore', e);
                alert('Ocurri√≥ un error al eliminar las pruebas. Revisa la consola para m√°s detalles.');
            }
        }

        if (btnEliminar) {
            btnEliminar.addEventListener('click', eliminarSeleccionadas);
        }

   // Delegaci√≥n de eventos para inputs/selects editables de prueba, noReporte y resultado
tbodyListado.addEventListener('change', (ev) => {
  const target = ev.target;
  if (!(target instanceof HTMLInputElement) && !(target instanceof HTMLSelectElement)) return;

  const id = target.getAttribute('data-id') || '';
  const valor = (target.value || '').trim();

  if (target.classList.contains('pl-prueba')) {
    actualizarCampoPrueba(id, valor);
  } else if (target.classList.contains('pl-norep')) {
    if (!valor) {
      alert('El campo "No. reporte / cert." es requerido.');
      const prev = target.getAttribute('data-prev') || '';
      target.value = prev;
      return;
    }
    actualizarCampoNoReporte(id, valor);
    target.setAttribute('data-prev', valor);
  } else if (target.classList.contains('pl-resultado')) {
    actualizarCampoResultado(id, valor);
  } else if (target.classList.contains('pl-periodo')) {
    actualizarCampoPeriodo(id, valor || '');
  } else if (target.classList.contains('pl-emisor')) {
    actualizarCampoEmisor(id, valor);
  } else if (target.classList.contains('pl-tecnico')) {
    actualizarCampoTecnico(id, valor);
  }
});

// Guardar ediciones al presionar Enter (sin depender de blur)
tbodyListado.addEventListener('keydown', (ev) => {
  const target = ev.target;
  if (!(target instanceof HTMLInputElement)) return;
  if (!target.classList.contains('pl-norep') && !target.classList.contains('pl-prueba') && !target.classList.contains('pl-emisor') && !target.classList.contains('pl-tecnico')) return;
  if (ev.key !== 'Enter') return;
  try { ev.preventDefault(); } catch {}
  try { target.blur(); } catch {}
});

// Mostrar los √∫ltimos d√≠gitos por defecto en No. reporte / cert.
tbodyListado.addEventListener('focusin', (ev) => {
  const target = ev.target;
  if (!(target instanceof HTMLInputElement)) return;
  if (!target.classList.contains('pl-norep')) return;
  const len = target.value.length;
  setTimeout(() => {
    try { target.setSelectionRange(len, len); } catch {}
    target.scrollLeft = target.scrollWidth;
  }, 0);
});

// Asegura ejecutar un render final tras registrar handlers
render();
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pruebas guardadas</title>
    <link rel="stylesheet" href="style.css">
    <style>
      /* Encabezado fijo para el listado principal de pruebas */
      #tabla-pruebas-listado thead {
        position: sticky;
        top: 0;
        z-index: 6;
        background: #f3f4f6;
      }
      #tabla-pruebas-listado thead th {
        position: sticky;
        top: 0;
        z-index: 7;
        background: #f3f4f6; /* mismo tono ya usado */
        box-shadow: 0 1px 0 0 #e5e7eb;
      }

      /* Barra de acciones (eliminar/exportar) fija al hacer scroll de p√°gina */
      .sticky-list-toolbar {
        position: sticky;
        top: 60px; /* bajo el header y la zona superior */
        z-index: 9;
        background: #ffffff;
        padding-top: 0.25rem;
        padding-bottom: 0.25rem;
      }

      /* Hacer el listado un panel scrollable para mantener visible su encabezado */
      .listado-scroll {
        overflow: auto;
        max-height: calc(100vh - 280px);
      }

      /* Chips de per√≠odo (arriba del Resumen) con estilo neutro gris y efecto activo */
      .chips-periodo .chip {
        background: #f8fafc; /* gris claro */
        border: 1px solid #e5e7eb;
        color: #111827;
        box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        background-image: none; /* elimina l√≠nea/gradiente superior si existiera */
        position: relative; /* para la l√≠nea superior */
        overflow: hidden;
      }
      /* Asegura que no se vea ninguna l√≠nea superior heredada */
      .chips-periodo .chip::before {
        content: none !important;
        display: none !important;
      }
      .chips-periodo .chip:hover {
        box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      }
      /* Resalta activo (el JS ya alterna dataset.active) */
      .chips-periodo .chip[data-active="1"] {
        box-shadow: 0 0 0 2px #2563eb inset; /* efecto active */
        font-weight: 700;
      }

    </style>
</head>
<body>
    <header>
        <div class="logo">
            <img src="img/logopctch.png" alt="Logo PCT">
        </div>
        <button class="nav-toggle" type="button" aria-label="Abrir men√∫">
            &#9776;
        </button>
        <nav class="nav-main">
            <ul>
                <li><a href="index.html">Inicio</a></li>

                <li class="nav-item-has-dropdown">
                    <a href="#" class="active">Pruebas</a>
                    <ul class="nav-dropdown">
                        <li><a href="pruebas.html">Registrar prueba</a></li>
                        <li><a href="pruebaslist.html">Listado de pruebas</a></li>
                    </ul>
                </li>

                <li class="nav-item-has-dropdown">
                    <a href="#">Inspecciones</a>
                    <ul class="nav-dropdown">
                        <li><a href="inspeccion.html">Nueva inspecci√≥n</a></li>
                        <li><a href="inspectlist.html">Listado de inspecciones</a></li>
                    </ul>
                </li>

                <li class="nav-item-has-dropdown">
                    <a href="#">Actividad</a>
                    <ul class="nav-dropdown">
                        <li><a href="actividad.html">Registrar actividad</a></li>
                        <li><a href="actividadlist.html">Listado de actividades</a></li>
                        <li><a href="actividadmin.html" class="nav-admin-only">Administraci√≥n</a></li>
                        <li><a href="trazabilidades.html" class="nav-admin-only">Trazabilidades</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
        <div class="user-info">
            <span class="user-info-email" id="nav-user-email"></span>
            <button id="btn-logout">Salir</button>
        </div>
    </header>

    <main style="max-width: 100%; margin: 0; padding: 0;">
        <section class="pruebaslist-wrap" style="padding: 0.75rem 0.75rem 1rem;">
            <h1 style="text-align:center; font-size:2.25rem; font-weight:800; letter-spacing:0.02em; margin:0.25rem 0 0.75rem; color:#111827;">
                VISOR DE PND Y CALIBRACIONES
            </h1>
            <section style="margin-bottom: 0.75rem;">
                <div style="display:flex; flex-wrap:wrap; gap:1rem; align-items:center; justify-content:center; font-size:1rem;">
                    <div id="chip-gt60" class="chip chip-large chip-green" style="cursor:pointer;">
                        > 60 d√≠as: <strong id="pruebas-alert-gt60">0</strong>
                    </div>
                    <div id="chip-60" class="chip chip-large chip-blue" style="cursor:pointer;">
                        60‚Äì31 d√≠as: <strong id="pruebas-alert-60">0</strong>
                    </div>
                    <div id="chip-30" class="chip chip-large chip-amber" style="cursor:pointer;">
                        30‚Äì16 d√≠as: <strong id="pruebas-alert-30">0</strong>
                    </div>
                    <div id="chip-15" class="chip chip-large chip-red" style="cursor:pointer;">
                        15‚Äì1 d√≠as: <strong id="pruebas-alert-15">0</strong>
                    </div>
                    <div id="chip-0" class="chip chip-large chip-black" style="cursor:pointer;">
                        üíÄ 0 d√≠as (vencidas): <strong id="pruebas-alert-0">0</strong>
                    </div>
                </div>
            </section>
            <p style="text-align:center; font-size:0.85rem; color:#6b7280; margin-top:0.25rem; margin-bottom:0.75rem;">
                Los rangos anteriores aplican √∫nicamente a pruebas <strong>ANUALES</strong>. Las pruebas de <strong>Post-trabajo</strong> y <strong>Reparaci√≥n</strong> siempre se muestran en el listado; sus chips sirven para filtrar por per√≠odo.
            </p>
        <!-- Chips de per√≠odo centrados antes del Resumen de estado -->
        <section style="margin: 0 0 0.75rem; display:flex; justify-content:center;">
            <div class="chips-periodo" style="display:flex; flex-wrap:wrap; gap:0.5rem; align-items:center;">
                <span id="pruebas-contador-historico" class="chip chip-large" style="font-weight:600;">
                    0 en hist√≥rico
                </span>
                <span id="pruebas-contador-anual" class="chip chip-large chip-blue" title="Pruebas ANUALES" style="cursor:pointer;">
                    Anual: 0
                </span>
                <span id="pruebas-contador-pt" class="chip chip-large chip-amber" title="Pruebas Post-trabajo" style="cursor:pointer;">
                    Post-trabajo: 0
                </span>
                <span id="pruebas-contador-rep" class="chip chip-large" title="Pruebas de Reparaci√≥n" style="cursor:pointer;">
                    Reparaci√≥n: 0
                </span>
            </div>
        </section>

        <section class="pruebas-dashboard" style="margin-bottom: 1.5rem;">
            <h2 style="margin-bottom:0.75rem;">Resumen de estado</h2>
            <section class="dashboard-cards" style="margin-bottom: 0.75rem;">
                <div class="dash-card" style="display:none;">
                    <div class="dash-card-label">Equipos con pruebas vigentes</div>
                    <div class="dash-card-value" id="pruebas-resumen-vigentes">0</div>
                    <div style="font-size:0.8rem; color:#4b5563; margin-top:0.25rem; line-height:1.2;">
                        <div>Por caducar (‚â§60 d√≠as): <strong id="pruebas-resumen-porcaducar">0</strong></div>
                        <div>Caducadas: <strong id="pruebas-resumen-caducadas">0</strong></div>
                    </div>
                </div>
                <div class="dash-card" style="display:none;">
                    <div class="dash-card-label">Equipos con prueba vencida</div>
                    <div class="dash-card-value" id="pruebas-resumen-vencidas">0</div>
                </div>
                <div class="dash-card" style="display:none;">
                    <div class="dash-card-label">Equipos sin prueba registrada</div>
                    <div class="dash-card-value" id="pruebas-resumen-sin">0</div>
                </div>
                <!-- Nueva tabla informativa por categor√≠a de prueba -->
            <section style="margin-bottom: 1rem;">
                <div class="tabla-inspecciones-wrapper" style="overflow-x:auto;">
                    <table id="tabla-informativa" style="width:100%; border-collapse:collapse; font-size:0.9rem; min-width:750px;">
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th style="text-align:left; padding:0.4rem; width:160px;">Tipo de Prueba</th>
                                <th style="text-align:center; padding:0.4rem;">Vigencia &gt; 60 d√≠as</th>
                                <th style="text-align:center; padding:0.4rem;">Vigencia 60-31 d√≠as</th>
                                <th style="text-align:center; padding:0.4rem;">Vigencia 30-16 d√≠as</th>
                                <th style="text-align:center; padding:0.4rem;">Vigencia 15-1 d√≠as</th>
                                <th style="text-align:center; padding:0.4rem;">0 d√≠as (vencidas)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th style="text-align:left; padding:0.4rem; background:#f9fafb;">LT</th>
                                <td id="inf-lt-gt60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-lt-60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-lt-30" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-lt-15" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-lt-0" style="text-align:center; padding:0.4rem;">0</td>
                            </tr>
                            <tr>
                                <th style="text-align:left; padding:0.4rem; background:#f9fafb;">VT/PT/MT</th>
                                <td id="inf-vpm-gt60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-vpm-60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-vpm-30" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-vpm-15" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-vpm-0" style="text-align:center; padding:0.4rem;">0</td>
                            </tr>
                            <tr>
                                <th style="text-align:left; padding:0.4rem; background:#f9fafb;">UTT</th>
                                <td id="inf-utt-gt60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-utt-60" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-utt-30" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-utt-15" style="text-align:center; padding:0.4rem;">0</td>
                                <td id="inf-utt-0" style="text-align:center; padding:0.4rem;">0</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>
        </section>

            

            <section style="margin-bottom:1rem; display:none;">
                <h3 style="font-size:1rem; margin-bottom:0.35rem;">Estado por equipo (√∫ltima prueba)</h3>
                <p style="font-size:0.85rem; color:#6b7280; margin-bottom:0.5rem;">
                    Para cada equipo se muestra la √∫ltima prueba registrada y su estado de vigencia. Este resumen no se ve afectado por el filtro de b√∫squeda.
                </p>
                <div class="tabla-inspecciones-wrapper" style="overflow-x:auto;">
                    <table id="tabla-pruebas-resumen" style="width:100%; border-collapse:collapse; font-size:0.9rem; min-width:900px;">
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th style="text-align:left; padding:0.4rem;">Equipo</th>
                                <th style="text-align:left; padding:0.4rem;">Descripci√≥n</th>
                                <th style="text-align:left; padding:0.4rem;">√öltima prueba</th>
                                <th style="text-align:left; padding:0.4rem;">Pr√≥xima prueba</th>
                                <th style="text-align:left; padding:0.4rem;">T√©cnico</th>
                                <th style="text-align:left; padding:0.4rem;">No. reporte / cert.</th>
                                <th style="text-align:left; padding:0.4rem;">Estado</th>
                            </tr>
                        </thead>
                        <tbody id="tbody-pruebas-resumen"></tbody>
                    </table>
                    <p id="mensaje-sin-pruebas-resumen" style="font-size:0.9rem; color:#6b7280; margin-top:0.75rem; display:none;">
                        No hay informaci√≥n de pruebas para resumir por equipo.
                    </p>
                </div>
            </section>
        </section>

        <section class="pruebas-panel" style="margin-bottom: 1.5rem;">
            <h2>Pruebas y calibraciones</h2>
            <p style="font-size:0.9rem; color:#6b7280; margin-bottom:0.75rem;">
                Se muestran las pruebas registradas en Firestore y su estado de vigencia seg√∫n la fecha de pr√≥xima prueba.
            </p>

            <section class="actividad-toolbar sticky-list-toolbar" style="margin-bottom: 0.5rem; display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center;">
                <!-- Left: search -->
                <div class="actividad-toolbar-left" style="display:flex; flex-wrap:wrap; gap:0.5rem; align-items:center;">
                    <input type="search" id="pruebas-buscar" placeholder="Buscar por equipo, producto, t√©cnico, reporte..." style="min-width: 260px;">
                </div>
                <!-- Right: actions -->
                <div class="actividad-toolbar-right" style="display:flex; gap:0.5rem; margin-left:auto;">
                    <input id="input-import-csv" type="file" accept=".csv" style="display:none;" />
                    <button id="btn-pruebas-import-csv" title="Importar formato_pruebas.csv" style="display:none;">Ingresar formato.csv</button>
                    <button id="btn-pruebas-eliminar">Eliminar seleccionadas</button>
                    <button id="btn-pruebas-export-csv">Exportar CSV</button>
                </div>
            </section>

            <section style="margin-bottom:1rem;">
                <h3 style="font-size:1rem; margin-bottom:0.35rem;">Listado de pruebas</h3>
                <p style="font-size:0.85rem; color:#6b7280; margin-bottom:0.5rem;">
                    Incluye todas las pruebas registradas. Las pruebas con pr√≥xima fecha vencida se resaltan en rojo.
                </p>
                <div class="tabla-inspecciones-wrapper listado-scroll" style="overflow-x:auto;">
                    <table id="tabla-pruebas-listado" style="width:100%; border-collapse:collapse; font-size:0.9rem; min-width:1050px;">
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th style="text-align:left; padding:0.4rem; width:32px;"><input type="checkbox" id="pruebas-select-todos"></th>
                                <th style="text-align:left; padding:0.4rem;">Fecha realizaci√≥n</th>
                                <th style="text-align:left; padding:0.4rem;">Pr√≥xima prueba</th>
                                <th style="text-align:left; padding:0.4rem;">Periodo</th>
                                <th style="text-align:left; padding:0.4rem;">Estado</th>
                                <th style="text-align:left; padding:0.4rem;">D√≠as para pr√≥xima</th>
                                <th style="text-align:left; padding:0.4rem;">Equipo</th>
                                <th style="text-align:left; padding:0.4rem;">Producto</th>
                                <th style="text-align:left; padding:0.4rem;">Descripci√≥n</th>
                                <th style="text-align:left; padding:0.4rem;">Prueba / Calib.</th>
                                <th style="text-align:left; padding:0.4rem;">√Årea inspecci√≥n</th>
                                <th style="text-align:left; padding:0.4rem;">No. reporte / cert.</th>
                                <th style="text-align:left; padding:0.4rem;">Resultado</th>
                                <th style="text-align:left; padding:0.4rem;">Emisor</th>
                                <th style="text-align:left; padding:0.4rem;">T√©cnico</th>
                            </tr>
                        </thead>
                        <tbody id="tbody-pruebas-listado"></tbody>
                    </table>
                    <p id="mensaje-sin-pruebas-listado" style="font-size:0.9rem; color:#6b7280; margin-top:0.75rem; display:none;">
                        No hay pruebas registradas todav√≠a.
                    </p>
                </div>
                <!-- Panel de vista previa de importaci√≥n CSV (solo admin) -->
                <section id="import-preview" style="display:none; margin-top:0.75rem; border:1px solid #e5e7eb; border-radius:8px; padding:0.75rem; background:#fafafa;">
                    <h3 style="margin:0 0 0.5rem;">Vista previa de importaci√≥n</h3>
                    <div id="import-summary" style="font-size:0.9rem; color:#374151; margin-bottom:0.5rem;"></div>
                    <div id="import-warnings" style="font-size:0.85rem; color:#92400e; margin-bottom:0.5rem;"></div>
                    <div id="import-errors" style="font-size:0.85rem; color:#991b1b; margin-bottom:0.5rem;"></div>
                    <div style="display:flex; gap:0.5rem;">
                        <button id="btn-import-confirm" style="display:none;">Confirmar importaci√≥n</button>
                        <button id="btn-import-cancel" style="display:none;">Cancelar</button>
                    </div>
                </section>
            </section>
        </section>

        </section>
    </main>

    <script src="nav.js"></script>

    <script type="module">
    import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

    const firebaseConfig = {
        apiKey: "AIzaSyCmutjS09d1hCjwlhuH0upkGr_TIVVBktc",
        authDomain: "xpct-tab.firebaseapp.com",
        projectId: "xpct-tab",
        storageBucket: "xpct-tab.firebasestorage.app",
        messagingSenderId: "614589989974",
        appId: "1:614589989974:web:e89a808180e4b563a8e7f7"
    };

    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const auth = getAuth(app);
    window.auth = auth;

    const emailSpan = document.getElementById('nav-user-email');
    const btnLogout = document.getElementById('btn-logout');

    onAuthStateChanged(auth, async (user) => {
        if (!user) {
            window.location.href = 'login.html';
            return;
        }

        // (Se calcula tras cargar las pruebas en cargarPruebasDesdeFirestore)

        const email = (user.email || '').toLowerCase();
        if (emailSpan) emailSpan.textContent = email;

        try {
            const idTok = await user.getIdTokenResult();
            const role = (idTok && idTok.claims && idTok.claims.role) || null;
            window.userRole = role;
            window.isAdmin = role === 'admin';
            window.isDirector = role === 'director';
            window.isSupervisor = role === 'supervisor';
            window.isInspector = role === 'inspector';
            window.isCapturista = role === 'capturista';
        } catch {}

        window.currentUserEmail = email;

        // Todos los roles autenticados pueden ver esta p√°gina; el UI ya se ajusta v√≠a nav.js
        cargarPruebasDesdeFirestore();
    });

    if (btnLogout) {
        btnLogout.addEventListener('click', async () => {
            try {
                await signOut(auth);
            } finally {
                window.location.href = 'login.html';
            }
        });
    }

    async function cargarPruebasDesdeFirestore() {
        const tbodyListado = document.getElementById('tbody-pruebas-listado');
        const msgListado = document.getElementById('mensaje-sin-pruebas-listado');
        const inputBuscar = document.getElementById('pruebas-buscar');
        const lblPend = document.getElementById('pruebas-contador-pendientes');
        const lblVenc = document.getElementById('pruebas-contador-vencidas');
        const lblHist = document.getElementById('pruebas-contador-historico');
        const lblAnual = document.getElementById('pruebas-contador-anual');
        const lblPT = document.getElementById('pruebas-contador-pt');
        const lblRep = document.getElementById('pruebas-contador-rep');

        const tbodyResumen = document.getElementById('tbody-pruebas-resumen');
        const msgResumen = document.getElementById('mensaje-sin-pruebas-resumen');
        const lblResVig = document.getElementById('pruebas-resumen-vigentes');
        const lblResVenc = document.getElementById('pruebas-resumen-vencidas');
        const lblResSin = document.getElementById('pruebas-resumen-sin');
        const lblResPorCad = document.getElementById('pruebas-resumen-porcaducar');
        const lblResCaducadas = document.getElementById('pruebas-resumen-caducadas');

        // Celdas de la tabla informativa
        const inf = {
            lt: {
                gt60: document.getElementById('inf-lt-gt60'),
                d60: document.getElementById('inf-lt-60'),
                d30: document.getElementById('inf-lt-30'),
                d15: document.getElementById('inf-lt-15'),
                d0:  document.getElementById('inf-lt-0'),
            },
            vpm: {
                gt60: document.getElementById('inf-vpm-gt60'),
                d60: document.getElementById('inf-vpm-60'),
                d30: document.getElementById('inf-vpm-30'),
                d15: document.getElementById('inf-vpm-15'),
                d0:  document.getElementById('inf-vpm-0'),
            },
            utt: {
                gt60: document.getElementById('inf-utt-gt60'),
                d60: document.getElementById('inf-utt-60'),
                d30: document.getElementById('inf-utt-30'),
                d15: document.getElementById('inf-utt-15'),
                d0:  document.getElementById('inf-utt-0'),
            }
        };

        const lblAlert60 = document.getElementById('pruebas-alert-60');
        const lblAlert30 = document.getElementById('pruebas-alert-30');
        const lblAlert15 = document.getElementById('pruebas-alert-15');

        // Chips de filtro por rango de d√≠as
        const chipGT60 = document.getElementById('chip-gt60');
        const chip60 = document.getElementById('chip-60');
        const chip30 = document.getElementById('chip-30');
        const chip15 = document.getElementById('chip-15');
        const chip0 = document.getElementById('chip-0');
        let filtroRango = null; // 'gt60' | '60' | '30' | '15' | '0' | null

        // Filtro por periodo (ANUAL / POST-TRABAJO / REPARACION)
        let filtroPeriodo = null; // null = todos, 'ANUAL' | 'POST-TRABAJO' | 'REPARACION'
        function actualizarChipsPeriodoActivos() {
            const activeStyle = (el, color) => {
                if (!el) return;
                if (el.dataset.active === '1') {
                    el.style.boxShadow = `0 0 0 2px ${color} inset`;
                    el.style.fontWeight = '700';
                } else {
                    el.style.boxShadow = '';
                    el.style.fontWeight = '';
                }
            };
            if (lblAnual) activeStyle(lblAnual, '#1d4ed8');
            if (lblPT) activeStyle(lblPT, '#f59e0b');
            if (lblRep) activeStyle(lblRep, '#6b7280');
        }
        function setFiltroPeriodo(nuevo) {
            filtroPeriodo = nuevo;
            if (lblAnual) lblAnual.dataset.active = (nuevo === 'ANUAL') ? '1' : '0';
            if (lblPT) lblPT.dataset.active = (nuevo === 'POST-TRABAJO') ? '1' : '0';
            if (lblRep) lblRep.dataset.active = (nuevo === 'REPARACION') ? '1' : '0';
            actualizarChipsPeriodoActivos();
            render();
        }

        if (lblAnual) {
            lblAnual.style.cursor = 'pointer';
            lblAnual.addEventListener('click', () => {
                setFiltroPeriodo((filtroPeriodo === 'ANUAL') ? null : 'ANUAL');
            });
        }
        if (lblPT) {
            lblPT.style.cursor = 'pointer';
            lblPT.addEventListener('click', () => {
                setFiltroPeriodo((filtroPeriodo === 'POST-TRABAJO') ? null : 'POST-TRABAJO');
            });
        }
        if (lblRep) {
            lblRep.style.cursor = 'pointer';
            lblRep.addEventListener('click', () => {
                setFiltroPeriodo((filtroPeriodo === 'REPARACION') ? null : 'REPARACION');
            });
        }

        const detallePanel = document.getElementById('detalle-prueba');
        const detalleContenido = document.getElementById('detalle-prueba-contenido');

        const chkSelectTodos = document.getElementById('pruebas-select-todos');
        const btnEliminar = document.getElementById('btn-pruebas-eliminar');
        const btnExportCsv = document.getElementById('btn-pruebas-export-csv');
        const btnImportCsv = document.getElementById('btn-pruebas-import-csv');
        const inputImportCsv = document.getElementById('input-import-csv');
        const importPreview = document.getElementById('import-preview');
        const importSummary = document.getElementById('import-summary');
        const importWarnings = document.getElementById('import-warnings');
        const importErrors = document.getElementById('import-errors');
        const btnImportConfirm = document.getElementById('btn-import-confirm');
        const btnImportCancel = document.getElementById('btn-import-cancel');

        const permitirEliminar = !!(window.isAdmin || window.isDirector);
        // Ocultar bot√≥n eliminar y cabecera de checkbox si no tiene permiso
        if (btnEliminar) btnEliminar.style.display = permitirEliminar ? '' : 'none';
        if (chkSelectTodos && chkSelectTodos.closest && chkSelectTodos.closest('th')) {
            chkSelectTodos.closest('th').style.display = permitirEliminar ? '' : 'none';
        }

        // Import CSV solo para admin
        if (btnImportCsv) btnImportCsv.style.display = (window.isAdmin ? '' : 'none');
        if (btnImportConfirm) btnImportConfirm.style.display = 'none';
        if (btnImportCancel) btnImportCancel.style.display = 'none';

        // Id (o clave) de la prueba actualmente seleccionada en el panel de detalle
        let pruebaSeleccionadaId = null;

        if (!tbodyListado) return;

        try {
            if (auth && auth.currentUser) {
                await auth.currentUser.getIdToken(true);
            }
        } catch {}

        let pruebas = [];
        const claveLocal = 'pct_pruebas';

        // Inventario base desde invre.csv para mostrar todos los equipos, incluso sin pruebas.
        let equiposInventario = new Set();
        let descripcionPorEquipoInv = {};

        async function leerFirestore() {
            try {
                const { getFirestore, collection, getDocs } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );

                const db = getFirestore(app);
                const colRef = collection(db, 'pruebas');
                const snap = await getDocs(colRef);
                return snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (e) {
                console.error('Error al leer pruebas desde Firestore, se usar√° localStorage como respaldo', e);
                return null;
            }
        }

        const desdeFs = await leerFirestore();
        if (desdeFs && Array.isArray(desdeFs)) {
            pruebas = desdeFs;
        } else {
            try {
                const crudo = JSON.parse(localStorage.getItem(claveLocal) || '[]');
                if (Array.isArray(crudo)) pruebas = crudo;
            } catch {
                pruebas = [];
            }
        }

        // Actualizar contadores de tipos (Anual, Post-trabajo, Reparaci√≥n) con base en TODAS las pruebas (sin filtros)
        (function actualizarContadoresTiposLocal() {
            if (!Array.isArray(pruebas)) return;
            let cAnual = 0, cPT = 0, cRep = 0;
            pruebas.forEach(reg => {
                const p = (reg && reg.periodo ? String(reg.periodo) : '').trim().toUpperCase();
                if (p === 'POST-TRABAJO') cPT += 1;
                else if (p === 'REPARACION') cRep += 1;
                else cAnual += 1; // incluye vac√≠o como ANUAL (compat)
            });
            if (lblAnual) lblAnual.textContent = `Anual: ${cAnual}`;
            if (lblPT) lblPT.textContent = `Post-trabajo: ${cPT}`;
            if (lblRep) lblRep.textContent = `Reparaci√≥n: ${cRep}`;
        })();

        async function cargarInventarioDesdeCsv() {
            try {
                const resp = await fetch('docs/invre.csv');
                if (!resp.ok) return;
                const texto = await resp.text();
                const lineas = texto.split(/\r?\n/).filter(l => l.trim() !== '');
                if (!lineas.length) return;

                const parse = (window && window.parseCSVLine) ? window.parseCSVLine : null;
                if (!parse) return;

                const headers = parse(lineas[0]);
                const idxEquipo = headers.indexOf('EQUIPO / ACTIVO');
                const idxDesc = headers.indexOf('DESCRIPCION');
                if (idxEquipo < 0) return;

                const setEq = new Set();
                const mapaDesc = {};

                lineas.slice(1).forEach(l => {
                    const cols = parse(l);
                    const eq = (cols[idxEquipo] || '').toString().trim();
                    if (!eq) return;
                    setEq.add(eq);
                    if (idxDesc >= 0) {
                        const desc = (cols[idxDesc] || '').toString().trim();
                        if (desc && !mapaDesc[eq]) {
                            mapaDesc[eq] = desc;
                        }
                    }
                });

                equiposInventario = setEq;
                descripcionPorEquipoInv = mapaDesc;
            } catch (e) {
                console.warn('No se pudo cargar invre.csv para resumen de pruebas', e);
            }
        }

        await cargarInventarioDesdeCsv();

        // ================== Importaci√≥n CSV (solo admin) ==================
        let importRowsReady = [];
        let existingKeys = new Set();

        function composeKey(r) {
            const equipo = (r.equipo||'').trim().toUpperCase();
            const numeroSerie = (r.numeroSerie||r.serial||'').trim().toUpperCase();
            const periodo = (r.periodo||'').trim().toUpperCase();
            const fechaRealizacion = (r.fechaRealizacion||'').trim();
            const noReporte = (r.noReporte||'').trim().toUpperCase();
            return `${equipo}__${numeroSerie}__${periodo}__${fechaRealizacion}__${noReporte}`;
        }

        function buildExistingKeys() {
            existingKeys = new Set();
            (pruebas||[]).forEach(reg => {
                const k = composeKey({
                    equipo: reg.equipo,
                    numeroSerie: reg.serial || reg.numeroSerie,
                    periodo: reg.periodo,
                    fechaRealizacion: reg.fechaRealizacion,
                    noReporte: reg.noReporte,
                });
                if (k) existingKeys.add(k);
            });
        }
        buildExistingKeys();

        function parseCsv(text) {
            const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
            if (!lines.length) return { headers: [], rows: [] };
            const parseLine = (line) => {
                const out = [];
                let cur = '';
                let inside = false;
                for (let i=0;i<line.length;i++) {
                    const ch = line[i];
                    if (ch === '"') {
                        if (inside && line[i+1] === '"') { cur += '"'; i++; }
                        else inside = !inside;
                    } else if (ch === ',' && !inside) {
                        out.push(cur); cur = '';
                    } else {
                        cur += ch;
                    }
                }
                out.push(cur);
                return out;
            };
            const headers = parseLine(lines[0]).map(h => String(h||'').trim());
            const rows = lines.slice(1).map(l => parseLine(l));
            return { headers, rows };
        }

        function req(val) { return val !== undefined && val !== null && String(val).trim() !== ''; }
        function isValidPeriodo(p) { const v = String(p||'').toUpperCase(); return v==='ANUAL' || v==='POST-TRABAJO' || v==='REPARACION'; }
        function isValidResultado(r) { const v = String(r||'').toUpperCase(); return v==='APROBADA' || v==='RECHAZADA' || v==='N/A'; }
        function isValidEjecucion(e) { if (!e) return true; const v = String(e||'').toUpperCase(); return v==='INTERNO' || v==='EXTERNO'; }
        function parseFechaDDMMAAAA(s) {
            const t = String(s||'').trim();
            const m = t.match(/^([0-3]?\d)\/([0-1]?\d)\/(\d{4})$/);
            if (!m) return null;
            const dd = parseInt(m[1],10), mm = parseInt(m[2],10), yyyy = parseInt(m[3],10);
            const d = new Date(yyyy, mm-1, dd); d.setHours(0,0,0,0);
            return isNaN(d.getTime()) ? null : d;
        }
        function formatDDMMAAAA(d) {
            const dd = String(d.getDate()).padStart(2,'0');
            const mm = String(d.getMonth()+1).padStart(2,'0');
            const yyyy = d.getFullYear();
            return `${dd}/${mm}/${yyyy}`;
        }
        function addDays(d, days) { const nd = new Date(d.getTime()); nd.setDate(nd.getDate()+days); return nd; }

        function validateCsv(text) {
            const expectHeaders = ['cliente','equipo','numeroSerie','periodo','prueba','fechaRealizacion','noReporte','resultado','ejecucion','emisor','pruebaDetalle','observaciones','ubicacion','areaPrueba','tecnico','proxima'];
            const { headers, rows } = parseCsv(text);
            const hdrStr = headers.join(',');
            const okHeaders = expectHeaders.join(',') === hdrStr;
            const errors = [];
            const warnings = [];
            const valids = [];
            if (!okHeaders) {
                errors.push(`Encabezados inv√°lidos. Se esperaba: ${expectHeaders.join(',')}. Se obtuvo: ${hdrStr}`);
                return { valids, errors, warnings };
            }

            rows.forEach((cols, idx) => {
                const n = idx + 2; // l√≠nea real
                const rec = Object.fromEntries(headers.map((h,i)=>[h, cols[i]!==undefined? String(cols[i]).trim() : '']));
                // Requeridos
                if (!req(rec.cliente)) errors.push(`L${n}: cliente requerido`);
                if (!req(rec.equipo)) errors.push(`L${n}: equipo requerido`);
                if (!req(rec.numeroSerie)) errors.push(`L${n}: numeroSerie requerido`);
                if (!req(rec.periodo) || !isValidPeriodo(rec.periodo)) errors.push(`L${n}: periodo inv√°lido (ANUAL|POST-TRABAJO|REPARACION)`);
                if (!req(rec.prueba)) errors.push(`L${n}: prueba requerida`);
                const f = parseFechaDDMMAAAA(rec.fechaRealizacion);
                if (!req(rec.fechaRealizacion) || !f) errors.push(`L${n}: fechaRealizacion inv√°lida (dd/mm/aaaa)`);
                if (!req(rec.noReporte)) errors.push(`L${n}: noReporte requerido`);
                if (!req(rec.resultado) || !isValidResultado(rec.resultado)) errors.push(`L${n}: resultado inv√°lido (APROBADA|RECHAZADA|N/A)`);
                if (!isValidEjecucion(rec.ejecucion)) errors.push(`L${n}: ejecucion inv√°lida (INTERNO|EXTERNO)`);
                if (String(rec.ejecucion||'').toUpperCase()==='EXTERNO' && !req(rec.emisor)) errors.push(`L${n}: emisor requerido cuando ejecucion=EXTERNO`);
                if (['VT','PT','MT'].includes(String(rec.prueba||'').toUpperCase()) && !req(rec.pruebaDetalle)) errors.push(`L${n}: pruebaDetalle requerido para VT/PT/MT`);

                // Inventario
                if (equiposInventario && equiposInventario.size && !equiposInventario.has(rec.equipo)) {
                    warnings.push(`L${n}: equipo no encontrado en inventario (se permitir√° la carga)`);
                }

                // Duplicados
                const k = composeKey(rec);
                if (existingKeys.has(k)) warnings.push(`L${n}: duplicado detectado (se omitir√° en la importaci√≥n)`);

                const hasRowError = errors.some(e => e.startsWith(`L${n}:`));
                if (!hasRowError) {
                    const periodo = String(rec.periodo).toUpperCase();
                    // Pr√≥xima para ANUAL
                    let proxima = '';
                    if (periodo === 'ANUAL' && req(rec.proxima)) {
                        const p = parseFechaDDMMAAAA(rec.proxima);
                        if (p) proxima = formatDDMMAAAA(p);
                        else warnings.push(`L${n}: proxima inv√°lida; se calcular√° autom√°ticamente`);
                    }
                    if (periodo === 'ANUAL' && !proxima && f) proxima = formatDDMMAAAA(addDays(f, 365));
                    // Emisor para INTERNO
                    let emisor = rec.emisor || '';
                    if (String(rec.ejecucion||'').toUpperCase()==='INTERNO') emisor = 'PCT';

                    valids.push({
                        cliente: rec.cliente,
                        equipo: rec.equipo,
                        serial: rec.numeroSerie,
                        periodo,
                        prueba: rec.prueba.toUpperCase(),
                        fechaRealizacion: formatDDMMAAAA(f),
                        noReporte: rec.noReporte,
                        resultado: String(rec.resultado||'').toUpperCase(),
                        ejecucion: String(rec.ejecucion||'').toUpperCase(),
                        emisor,
                        pruebaDetalle: rec.pruebaDetalle || '',
                        observaciones: rec.observaciones || '',
                        ubicacion: rec.ubicacion || '',
                        areaPrueba: rec.areaPrueba || '',
                        tecnico: rec.tecnico || '',
                        proxima
                    });
                }
            });

            return { valids, errors, warnings };
        }

        function renderImportPreview(res) {
            if (!importPreview) return;
            const total = (res.valids?.length||0) + (res.errors?.filter(e=>/^L\d+:/.test(e)).length||0);
            importSummary.innerHTML = `Registros v√°lidos: <strong>${res.valids.length}</strong> de ${total}`;
            importWarnings.innerHTML = res.warnings.length ? (`<ul>` + res.warnings.slice(0,50).map(w=>`<li>${w}</li>`).join('') + (res.warnings.length>50?`<li>... (${res.warnings.length-50} m√°s)</li>`:'') + `</ul>`) : '';
            importErrors.innerHTML = res.errors.length ? (`<ul>` + res.errors.slice(0,50).map(e=>`<li>${e}</li>`).join('') + (res.errors.length>50?`<li>... (${res.errors.length-50} m√°s)</li>`:'') + `</ul>`) : '';
            importPreview.style.display = '';
            if (btnImportConfirm) btnImportConfirm.style.display = res.valids.length ? '' : 'none';
            if (btnImportCancel) btnImportCancel.style.display = '';
        }

        async function doImportToFirestore(rows) {
            const { getFirestore, collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js');
            const db = getFirestore(app);
            let ok = 0, skipped = 0, failed = 0;
            for (const r of rows) {
                const k = composeKey({
                    equipo: r.equipo,
                    numeroSerie: r.serial,
                    periodo: r.periodo,
                    fechaRealizacion: r.fechaRealizacion,
                    noReporte: r.noReporte,
                });
                if (existingKeys.has(k)) { skipped++; continue; }
                const payload = {
                    cliente: r.cliente,
                    equipo: r.equipo,
                    serial: r.serial,
                    periodo: r.periodo,
                    prueba: r.prueba,
                    fechaRealizacion: r.fechaRealizacion,
                    noReporte: r.noReporte,
                    resultado: r.resultado,
                    ejecucion: r.ejecucion,
                    emisor: r.emisor,
                    pruebaDetalle: r.pruebaDetalle,
                    observaciones: r.observaciones,
                    ubicacion: r.ubicacion,
                    areaPrueba: r.areaPrueba,
                    tecnico: r.tecnico,
                    creadoEn: serverTimestamp(),
                };
                if (r.periodo === 'ANUAL' && r.proxima) payload.proxima = r.proxima;
                try {
                    await addDoc(collection(db, 'pruebas'), payload);
                    existingKeys.add(k);
                    ok++;
                } catch (e) {
                    console.error('Error insertando fila import', e);
                    failed++;
                }
            }
            return { ok, skipped, failed };
        }

        if (btnImportCsv && inputImportCsv) {
            btnImportCsv.addEventListener('click', () => inputImportCsv.click());
            inputImportCsv.addEventListener('change', async (ev) => {
                const file = ev.target.files && ev.target.files[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    const res = validateCsv(text);
                    importRowsReady = res.valids;
                    renderImportPreview(res);
                } catch (e) {
                    alert('No se pudo leer el archivo CSV');
                }
            });
        }

        if (btnImportConfirm) {
            btnImportConfirm.addEventListener('click', async () => {
                if (!window.isAdmin) return;
                btnImportConfirm.disabled = true;
                try {
                    const res = await doImportToFirestore(importRowsReady||[]);
                    importSummary.innerHTML += ` ‚Äî Importados: <strong>${res.ok}</strong>, Omitidos (duplicados): ${res.skipped}, Fallidos: ${res.failed}`;
                    // Recargar listado
                    const desdeFs2 = await leerFirestore();
                    if (desdeFs2 && Array.isArray(desdeFs2)) pruebas = desdeFs2;
                    buildExistingKeys();
                    render();
                } finally {
                    btnImportConfirm.disabled = false;
                }
            });
        }

        if (btnImportCancel) {
            btnImportCancel.addEventListener('click', () => {
                if (importPreview) importPreview.style.display = 'none';
                if (importSummary) importSummary.innerHTML = '';
                if (importWarnings) importWarnings.innerHTML = '';
                if (importErrors) importErrors.innerHTML = '';
                importRowsReady = [];
                if (inputImportCsv) inputImportCsv.value = '';
            });
        }

        // Helpers para formatear 'Fecha de registro' (usa creadoEn con fallback a fechaPrueba)
        function toDateGeneric(val) {
            if (!val) return null;
            try {
                if (val && typeof val === 'object' && typeof val.toDate === 'function') {
                    return val.toDate();
                }
                if (val instanceof Date) return new Date(val);
                if (typeof val === 'number' && isFinite(val)) return new Date(val);
                const s = String(val).trim();
                if (!s) return null;
                const d = new Date(s);
                return isNaN(d.getTime()) ? null : d;
            } catch { return null; }
        }

        function formatoFechaHora(d) {
            if (!d || isNaN(d.getTime())) return '';
            const dd = String(d.getDate()).padStart(2, '0');
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const yyyy = d.getFullYear();
            const hh = String(d.getHours()).padStart(2, '0');
            const mi = String(d.getMinutes()).padStart(2, '0');
            return `${dd}/${mm}/${yyyy} ${hh}:${mi}`;
        }

        function obtenerFechaRegistroTexto(reg) {
            const d = toDateGeneric(reg && reg.creadoEn);
            if (d) return formatoFechaHora(d);
            const d2 = toDateGeneric(reg && reg.fechaPrueba);
            return d2 ? formatoFechaHora(d2) : '';
        }

        function parseFechaRealizacion(val) {
            if (!val) return null;
            // Firestore Timestamp
            if (val && typeof val === 'object' && typeof val.toDate === 'function') {
                const d = val.toDate(); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d;
            }
            // Date
            if (val instanceof Date) { const d = new Date(val); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d; }
            // Milliseconds number
            if (typeof val === 'number' && isFinite(val)) { const d = new Date(val); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d; }
            const s = String(val).trim();
            if (!s) return null;
            // dd/mm/aa o dd/mm/aaaa
            if (s.includes('/')) {
                const partes = s.split('/');
                if (partes.length !== 3) return null;
                const [ddStr, mmStr, aaStr] = partes;
                const dd = parseInt(ddStr, 10);
                const mm = parseInt(mmStr, 10);
                const aa = parseInt(aaStr, 10);
                if (!dd || !mm || isNaN(aa)) return null;
                const year = aaStr.length <= 2 ? (2000 + aa) : aa;
                const d = new Date(year, mm - 1, dd);
                d.setHours(0,0,0,0);
                return isNaN(d.getTime()) ? null : d;
            }
            // ISO u otros formatos parseables por Date
            const d = new Date(s);
            if (isNaN(d.getTime())) return null;
            d.setHours(0,0,0,0);
            return d;
        }

        function mostrarDetallePrueba(reg) {
            if (!detalleContenido) return;

            // Construir una clave estable para comparar selecciones repetidas
            const clave =
                (reg && reg.id) ||
                `${reg.equipo || ''}__${reg.fechaRealizacion || ''}__${reg.noReporte || ''}`;

            // Si se hace clic de nuevo sobre la misma prueba, contraer el panel
            if (pruebaSeleccionadaId && pruebaSeleccionadaId === clave) {
                detalleContenido.innerHTML =
                    'No hay ninguna prueba seleccionada.';
                pruebaSeleccionadaId = null;
                return;
            }

            // C√°lculo de d√≠as para pr√≥xima prueba (mismo criterio que en el listado)
            let diasParaProximaDetalle = '';
            if (reg.proxima) {
                const d = parseProxima(reg.proxima);
                if (d) {
                    const hoy = hoySinHora();
                    const diffMs = d.getTime() - hoy.getTime();
                    let dias = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    if (dias < 0) dias = 0;
                    diasParaProximaDetalle = String(dias);
                }
            }

            const campos = [
                ['Equipo', reg.equipo || ''],
                ['Serial', reg.serial || ''],
                ['Producto', reg.producto || ''],
                ['Descripci√≥n', reg.descripcion || ''],
                ['Prueba / Calibraci√≥n', reg.prueba || reg.pruebaTipo || ''],
                ['Resultado', reg.resultado || ''],
                ['Periodo', reg.periodo || ''], 
                ['Fecha de registro', obtenerFechaRegistroTexto(reg)],
                ['Fecha realizaci√≥n', reg.fechaRealizacion || ''],
                ['Pr√≥xima prueba', reg.proxima || ''],
                ['D√≠as para pr√≥xima', diasParaProximaDetalle],
                ['No. reporte / certificado', reg.noReporte || ''],
                ['T√©cnico', reg.tecnico || ''],
                ['Emisor', reg.emisor || ''],
                ['Propiedad', reg.propiedad || ''],
                ['√Årea a inspeccionar', reg.area || ''],
                ['Observaciones', reg.observaciones || '']
            ];

            const filasHtml = campos
                .filter(([_, valor]) => valor !== undefined && valor !== null && String(valor).trim() !== '')
                .map(([label, valor]) => `
                    <tr>
                        <th style="text-align:left; padding:0.2rem 0.5rem; width:180px; color:#4b5563; font-weight:600;">${label}</th>
                        <td style="padding:0.2rem 0.5rem;">${String(valor)}</td>
                    </tr>
                `)
                .join('');

            detalleContenido.innerHTML = `
                <table style="width:100%; border-collapse:collapse; font-size:0.88rem;">
                    <tbody>
                        ${filasHtml || '<tr><td style="padding:0.4rem; color:#6b7280;">Sin datos para esta prueba.</td></tr>'}
                    </tbody>
                </table>
            `;

            pruebaSeleccionadaId = clave;
        }

        // Construir el HTML del detalle (reutiliza las mismas filas de mostrarDetallePrueba)
        function construirDetalleHTML(reg) {
            let diasParaProximaDetalle = '';
            if (reg.proxima) {
                const d = parseProxima(reg.proxima);
                if (d) {
                    const hoy = hoySinHora();
                    const diffMs = d.getTime() - hoy.getTime();
                    let dias = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    if (dias < 0) dias = 0;
                    diasParaProximaDetalle = String(dias);
                }
            }

            const campos = [
                ['Equipo', reg.equipo || ''],
                ['Serial', reg.serial || ''],
                ['Producto', reg.producto || ''],
                ['Descripci√≥n', reg.descripcion || ''],
                ['Prueba / Calibraci√≥n', reg.prueba || reg.pruebaTipo || ''],
                ['Resultado', reg.resultado || ''],
                ['Periodo', reg.periodo || ''],
                ['Fecha de registro', obtenerFechaRegistroTexto(reg)],
                ['Fecha realizaci√≥n', reg.fechaRealizacion || ''],
                ['Pr√≥xima prueba', reg.proxima || ''],
                ['D√≠as para pr√≥xima', diasParaProximaDetalle],
                ['No. reporte / certificado', reg.noReporte || ''],
                ['T√©cnico', reg.tecnico || ''],
                ['Emisor', reg.emisor || ''],
                ['Propiedad', reg.propiedad || ''],
                ['√Årea a inspeccionar', reg.area || ''],
                ['Observaciones', reg.observaciones || '']
            ];

            const filasHtml = campos
                .filter(([_, valor]) => valor !== undefined && valor !== null && String(valor).trim() !== '')
                .map(([label, valor]) => `
                    <tr>
                        <th style="text-align:left; padding:0.2rem 0.5rem; width:180px; color:#4b5563; font-weight:600;">${label}</th>
                        <td style="padding:0.2rem 0.5rem;">${String(valor)}</td>
                    </tr>
                `)
                .join('');

            return `
                <div style="font-size:0.9rem; color:#111827; border:1px solid #e5e7eb; border-radius:0.5rem; padding:0.75rem; background:#f9fafb;">
                    <table style="width:100%; border-collapse:collapse; font-size:0.88rem;">
                        <tbody>
                            ${filasHtml || '<tr><td style="padding:0.4rem; color:#6b7280;">Sin datos para esta prueba.</td></tr>'}
                        </tbody>
                    </table>
                </div>`;
        }

        // Alterna una fila de detalle inmediatamente debajo de la fila clicada
        function toggleDetalleInline(fila, reg) {
            const tbody = fila.parentElement;
            if (!tbody) return;

            // Si ya estaba abierto justo debajo, colapsar y salir
            const next = fila.nextElementSibling;
            if (next && next.classList && next.classList.contains('pl-detalle-row')) {
                next.remove();
                fila.classList.remove('pl-active');
                return;
            }

            // Cerrar cualquier otro detalle abierto previamente
            const abiertos = tbody.querySelectorAll('tr.pl-detalle-row');
            abiertos.forEach(tr => tr.remove());
            tbody.querySelectorAll('tr.pl-active').forEach(tr => tr.classList.remove('pl-active'));

            const detalleTr = document.createElement('tr');
            detalleTr.className = 'pl-detalle-row';
            const detalleTd = document.createElement('td');
            detalleTd.colSpan = permitirEliminar ? 15 : 14; // ajustar si no hay columna de selecci√≥n
            detalleTd.innerHTML = construirDetalleHTML(reg);
            detalleTr.appendChild(detalleTd);
            fila.insertAdjacentElement('afterend', detalleTr);
            fila.classList.add('pl-active');
        }

        function hoySinHora() {
            const d = new Date();
            d.setHours(0, 0, 0, 0);
            return d;
        }

        function formateaDDMMAA(d) {
            if (!(d instanceof Date) || isNaN(d.getTime())) return '';
            const dd = String(d.getDate()).padStart(2, '0');
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const aa = String(d.getFullYear()).slice(-2);
            return `${dd}/${mm}/${aa}`;
        }

        function parseProxima(val) {
            if (!val) return null;
            // Firestore Timestamp
            if (val && typeof val === 'object' && typeof val.toDate === 'function') {
                const d = val.toDate(); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d;
            }
            // Date instancia
            if (val instanceof Date) { const d = new Date(val); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d; }
            // Milliseconds
            if (typeof val === 'number' && isFinite(val)) { const d = new Date(val); d.setHours(0,0,0,0); return isNaN(d.getTime()) ? null : d; }
            const s = String(val).trim();
            if (!s) return null;
            // dd/mm/aa o dd/mm/aaaa
            if (s.includes('/')) {
                const partes = s.split('/');
                if (partes.length !== 3) return null;
                const [ddStr, mmStr, aaStr] = partes;
                const dd = parseInt(ddStr, 10);
                const mm = parseInt(mmStr, 10);
                const aa = parseInt(aaStr, 10);
                if (!dd || !mm || isNaN(aa)) return null;
                const year = aaStr.length <= 2 ? (2000 + aa) : aa;
                const d = new Date(year, mm - 1, dd);
                if (isNaN(d.getTime())) return null;
                d.setHours(0,0,0,0);
                return d;
            }
            // ISO u otros
            const d = new Date(s);
            if (isNaN(d.getTime())) return null;
            d.setHours(0,0,0,0);
            return d;
        }

        function clasificarPrueba(reg) {
            let proxima = parseProxima(reg.proxima || '');
            // Si no hay 'proxima' pero es ANUAL, intentar derivarla de fechaRealizacion + 12 meses
            if (!proxima) {
                const periodo = (reg.periodo || '').toString().trim().toUpperCase();
                const fr = parseFechaRealizacion(reg.fechaRealizacion || reg.fechaPrueba || '');
                // Backward compat: sin periodo => tratar como ANUAL
                if ((periodo === 'ANUAL' || !periodo) && fr) {
                    const d = new Date(fr);
                    d.setFullYear(d.getFullYear() + 1);
                    d.setHours(0,0,0,0);
                    if (!isNaN(d.getTime())) proxima = d;
                }
            }
            if (!proxima) return { estado: 'SIN_FECHA', proxima: null };
            const hoy = hoySinHora();
            if (proxima < hoy) return { estado: 'VENCIDA', proxima };
            return { estado: 'VIGENTE', proxima };
        }

        function render() {
            const filtro = (inputBuscar?.value || '').toLowerCase().trim();

            tbodyListado.innerHTML = '';
            if (msgListado) msgListado.style.display = 'none';
            if (tbodyResumen) tbodyResumen.innerHTML = '';
            if (msgResumen) msgResumen.style.display = 'none';

            if (!pruebas.length && (!equiposInventario || !equiposInventario.size)) {
                if (msgListado) msgListado.style.display = 'block';
                if (msgResumen) msgResumen.style.display = 'block';
                if (lblPend) lblPend.textContent = '0 por realizar';
                if (lblVenc) lblVenc.textContent = '0 vencidas';
                if (lblHist) lblHist.textContent = '0 en hist√≥rico';
                if (lblResVig) lblResVig.textContent = '0';
                if (lblResVenc) lblResVenc.textContent = '0';
                if (lblResSin) lblResSin.textContent = '0';
                if (lblResPorCad) lblResPorCad.textContent = '0';
                if (lblResCaducadas) lblResCaducadas.textContent = '0';
                return;
            }

            const hoy = hoySinHora();

            const enriquecidas = pruebas.map(reg => {
                const clasif = clasificarPrueba(reg);
                const fechaReal = parseFechaRealizacion(reg.fechaRealizacion || '') || hoySinHora();
                return { ...reg, _clasif: clasif, _fechaRealDate: fechaReal };
            });

            const porRealizar = [];
            const historico = [...enriquecidas];

            enriquecidas.forEach(reg => {
                if (reg._clasif.estado === 'VIGENTE' || reg._clasif.estado === 'VENCIDA') {
                    porRealizar.push(reg);
                }
            });

            // Construir referencia: √∫ltima ANUAL por equipo
            const anualPorEquipo = new Map();
            enriquecidas.forEach(reg => {
                const eq = (reg.equipo || '').toString();
                if (!eq) return;
                const periodo = (reg.periodo || '').toString().trim().toUpperCase();
                // Backward compat: registros sin periodo se consideran ANUAL
                if (periodo && periodo !== 'ANUAL') return;
                const actual = anualPorEquipo.get(eq);
                if (!actual || reg._fechaRealDate.getTime() > actual._fechaRealDate.getTime()) {
                    anualPorEquipo.set(eq, reg);
                }
            });

            // Construir referencia de categor√≠a por registro (LT, VT/PT/MT, UTT)
            function categoriaPrueba(reg) {
                const p = ((reg.prueba || reg.pruebaTipo || '') + '').toUpperCase();
                if (!p) return null;
                if (p.includes('UTT')) return 'utt';
                if (p.includes('LT')) return 'lt';
                if (p.includes('VT') || p.includes('PT') || p.includes('MT')) return 'vpm';
                return null;
            }

            // Inicializar contadores
            const cont = {
                lt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                vpm: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                utt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
            };

            // Post-trabajo y Reparaci√≥n distribuidos por buckets seg√∫n fecha de realizaci√≥n (antig√ºedad)
            const pt = {
                lt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                vpm: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                utt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
            };
            const rep = {
                lt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                vpm: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
                utt: { gt60: 0, d60: 0, d30: 0, d15: 0, d0: 0 },
            };

            // Clasificar por buckets por REGISTRO (prueba), no por equipo
            (Array.isArray(historico) ? historico : []).forEach(reg => {
                const periodo = (reg.periodo || '').toString().trim().toUpperCase();
                // Solo ANUAL define pr√≥xima (y por tanto, vigencia)
                if (periodo && periodo !== 'ANUAL') return;
                const cat = categoriaPrueba(reg);
                if (!cat) return;
                const prox = parseProxima(reg.proxima || '') || (reg._clasif?.proxima || null);
                if (!prox) return;
                const dias = Math.round((prox.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
                if (isNaN(dias)) return;
                if (dias <= 0) { cont[cat].d0 += 1; return; }
                if (dias > 60) cont[cat].gt60 += 1;
                else if (dias >= 31) cont[cat].d60 += 1;
                else if (dias >= 16) cont[cat].d30 += 1;
                else if (dias >= 1) cont[cat].d15 += 1; // 1..15
            });

            // Contar Post-trabajo y Reparaci√≥n por categor√≠a y bucket (seg√∫n fecha de realizaci√≥n)
            (Array.isArray(historico) ? historico : []).forEach(reg => {
                const periodo = (reg.periodo || '').toString().trim().toUpperCase();
                const cat = categoriaPrueba(reg);
                if (!cat) return;
                if (periodo !== 'POST-TRABAJO' && periodo !== 'REPARACION') return;
                const fr = reg._fechaRealDate instanceof Date ? reg._fechaRealDate : parseFechaRealizacion(reg.fechaRealizacion || '');
                if (!fr) return;
                const dAnt = Math.max(0, Math.round((hoy.getTime() - fr.getTime()) / (1000 * 60 * 60 * 24)));
                const bucket = (dAnt === 0) ? 'd0' : (dAnt >= 1 && dAnt <= 15) ? 'd15' : (dAnt >= 16 && dAnt <= 30) ? 'd30' : (dAnt >= 31 && dAnt <= 60) ? 'd60' : 'gt60';
                if (periodo === 'POST-TRABAJO') pt[cat][bucket] += 1;
                else if (periodo === 'REPARACION') rep[cat][bucket] += 1;
            });

            // Pintar tabla informativa (solo conteo ANUAL por rango)
            try {
                if (inf.lt.gt60) inf.lt.gt60.textContent = String(cont.lt.gt60);
                if (inf.lt.d60)  inf.lt.d60.textContent  = String(cont.lt.d60);
                if (inf.lt.d30)  inf.lt.d30.textContent  = String(cont.lt.d30);
                if (inf.lt.d15)  inf.lt.d15.textContent  = String(cont.lt.d15);
                if (inf.lt.d0)   inf.lt.d0.textContent   = String(cont.lt.d0);

                if (inf.vpm.gt60) inf.vpm.gt60.textContent = String(cont.vpm.gt60);
                if (inf.vpm.d60)  inf.vpm.d60.textContent  = String(cont.vpm.d60);
                if (inf.vpm.d30)  inf.vpm.d30.textContent  = String(cont.vpm.d30);
                if (inf.vpm.d15)  inf.vpm.d15.textContent  = String(cont.vpm.d15);
                if (inf.vpm.d0)   inf.vpm.d0.textContent   = String(cont.vpm.d0);

                if (inf.utt.gt60) inf.utt.gt60.textContent = String(cont.utt.gt60);
                if (inf.utt.d60)  inf.utt.d60.textContent  = String(cont.utt.d60);
                if (inf.utt.d30)  inf.utt.d30.textContent  = String(cont.utt.d30);
                if (inf.utt.d15)  inf.utt.d15.textContent  = String(cont.utt.d15);
                if (inf.utt.d0)   inf.utt.d0.textContent   = String(cont.utt.d0);
            } catch {}

            // Resumen por equipo (√∫ltima ANUAL) incluyendo equipos sin ANUAL (desde inventario)
            if (tbodyResumen && lblResVig && lblResVenc && lblResSin) {
                const listaEquiposBase = equiposInventario && equiposInventario.size
                    ? Array.from(equiposInventario)
                    : Array.from(anualPorEquipo.keys());

                if (!listaEquiposBase.length && msgResumen) {
                    msgResumen.style.display = 'block';
                }

                let cntEquiposVig = 0;
                let cntEquiposVenc = 0;
                let cntEquiposSin = 0;
                let cntEquiposPorCaducar = 0;

                listaEquiposBase.sort((a, b) => a.localeCompare(b)).forEach(eq => {
                    const reg = anualPorEquipo.get(eq) || null;
                    const estado = reg ? reg._clasif.estado : 'SIN_PRUEBA';

                    if (estado === 'VIGENTE') {
                        cntEquiposVig += 1;
                        const dProx = parseProxima(reg ? (reg.proxima || '') : '');
                        if (dProx) {
                            const dias = Math.round((dProx.getTime() - hoy.getTime()) / (1000 * 60 * 60 * 24));
                            if (dias >= 0 && dias <= 60) cntEquiposPorCaducar += 1;
                        }
                    } else if (estado === 'VENCIDA') {
                        cntEquiposVenc += 1;
                    } else {
                        cntEquiposSin += 1;
                    }

                    const fila = document.createElement('tr');
                    const proximaStr = reg ? (reg.proxima || '') : '';
                    const fechaReal = reg ? (reg.fechaRealizacion || '') : '';
                    const tecnico = reg ? (reg.tecnico || '') : '';
                    const noRep = reg ? (reg.noReporte || '') : '';
                    const desc = reg && reg.descripcion
                        ? reg.descripcion
                        : (descripcionPorEquipoInv[eq] || '');

                    const badge =
                        estado === 'VIGENTE'
                            ? '<span style="padding:0.1rem 0.5rem; border-radius:999px; background:#dcfce7; color:#166534; font-size:0.75rem;">Vigente</span>'
                            : estado === 'VENCIDA'
                                ? '<span style="padding:0.1rem 0.5rem; border-radius:999px; background:#fee2e2; color:#b91c1c; font-size:0.75rem;">Vencida</span>'
                                : '<span style="padding:0.1rem 0.5rem; border-radius:999px; background:#e5e7eb; color:#374151; font-size:0.75rem;">Sin prueba</span>';

                    fila.innerHTML = `
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${eq}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${desc}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${fechaReal}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${proximaStr}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${tecnico}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${noRep}</td>
                        <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${badge}</td>
                    `;
                    tbodyResumen.appendChild(fila);
                });

                lblResVig.textContent = String(cntEquiposVig);
                lblResVenc.textContent = String(cntEquiposVenc);
                lblResSin.textContent = String(cntEquiposSin);
                if (lblResPorCad) lblResPorCad.textContent = String(cntEquiposPorCaducar);
                if (lblResCaducadas) lblResCaducadas.textContent = String(cntEquiposVenc);
            }

            // Ordenar priorizando pr√≥ximas a vencer (VIGENTE con d√≠as >= 0, ascendente) POR PRUEBA,
            // luego vencidas, luego sin fecha, y en cada grupo por fecha de realizaci√≥n desc.
            function diasHastaProxima(reg) {
                const clasif = clasificarPrueba(reg);
                if (!clasif || !clasif.proxima) return null;
                const hoy0 = hoySinHora();
                const diffMs = clasif.proxima.getTime() - hoy0.getTime();
                let dias = Math.round(diffMs / (1000 * 60 * 60 * 24));
                return dias;
            }

            const listaOrdenada = [...historico].sort((a, b) => {
                const da = diasHastaProxima(a);
                const db = diasHastaProxima(b);
                const ea = (clasificarPrueba(a)?.estado) || 'SIN_FECHA';
                const eb = (clasificarPrueba(b)?.estado) || 'SIN_FECHA';

                const cat = (regEstado, dias) => {
                    if (regEstado === 'VIGENTE' && dias !== null && dias >= 0) return 0; // pr√≥ximas a vencer
                    if (regEstado === 'VENCIDA') return 1; // vencidas
                    return 2; // sin fecha u otros
                };

                const ca = cat(ea, da);
                const cb = cat(eb, db);
                if (ca !== cb) return ca - cb;

                if (ca === 0) {
                    // Ambos en pr√≥ximas a vencer: menor d√≠as primero
                    if (da !== db) return (da ?? Number.POSITIVE_INFINITY) - (db ?? Number.POSITIVE_INFINITY);
                }

                // Mismo grupo: m√°s reciente primero
                return b._fechaRealDate.getTime() - a._fechaRealDate.getTime();
            });

            let cntPend = 0;
            let cntVenc = 0;
            let cntHist = 0;

            // Chips: contar PRUEBAS (no equipos)
            let cntChipGT60 = 0; // > 60
            let cntChip60 = 0;   // 60‚Äì31
            let cntChip30 = 0;   // 30‚Äì16
            let cntChip15 = 0;   // 15‚Äì1
            let cntChip0 = 0;    // 0 (vencidas)

            const filasVisibles = [];

            listaOrdenada.forEach(reg => {
                const textoBuscar = `${reg.equipo || ''} ${reg.producto || ''} ${reg.descripcion || ''} ${reg.tecnico || ''} ${reg.noReporte || ''}`.toLowerCase();
                if (filtro && !textoBuscar.includes(filtro)) return;

                const clasifOriginal = clasificarPrueba(reg);
                const periodoReg = (reg.periodo || '').toString().trim().toUpperCase();
                const esAnualReg = (periodoReg === 'ANUAL' || !periodoReg);
                const refAnual = !esAnualReg ? (anualPorEquipo.get((reg.equipo || '').toString()) || null) : null;
                const clasifRef = refAnual ? (refAnual._clasif || clasificarPrueba(refAnual)) : null;

                // Mostrar estado/pr√≥xima basado en ANUAL de referencia para Post/Reparaci√≥n
                const estado = (!esAnualReg && clasifRef) ? (clasifRef.estado || 'SIN_FECHA') : (clasifOriginal ? clasifOriginal.estado : 'SIN_FECHA');
                const proximaBase = (!esAnualReg && clasifRef && clasifRef.proxima)
                    ? clasifRef.proxima
                    : (clasifOriginal && clasifOriginal.proxima) ? clasifOriginal.proxima : null;
                const proximaStr = proximaBase
                    ? ( (!esAnualReg && refAnual && refAnual.proxima) ? String(refAnual.proxima) : formateaDDMMAA(proximaBase) )
                    : '';

                const fila = document.createElement('tr');

                if (estado === 'VENCIDA') {
                    fila.style.background = '#fef2f2';
                    fila.style.color = '#b91c1c';
                }

                // C√°lculo de d√≠as restantes hasta la pr√≥xima prueba
                let diasParaProxima = '';
                let diasNum = null;
                if (proximaBase) {
                    const hoy = hoySinHora();
                    const diffMs = proximaBase.getTime() - hoy.getTime();
                    let dias = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    if (dias < 0) dias = 0; // para vencidas mostramos 0
                    diasNum = dias;
                    diasParaProxima = String(dias);
                }

                // Contar alertas por PRUEBA (no por equipo), solo vigentes; rangos: 60‚Äì31, 30‚Äì16, 15‚Äì1
                // esAnualReg ya calculado arriba
                if (esAnualReg && estado === 'VIGENTE' && diasNum !== null && diasNum >= 1) {
                    if (diasNum >= 31 && diasNum <= 60) {
                        cntChip60 += 1;
                    } else if (diasNum >= 16 && diasNum <= 30) {
                        cntChip30 += 1;
                    } else if (diasNum >= 1 && diasNum <= 15) {
                        cntChip15 += 1;
                    }
                }
                if (esAnualReg && estado === 'VIGENTE' && diasNum !== null && diasNum > 60) {
                    cntChipGT60 += 1;
                }
                if (esAnualReg && estado === 'VENCIDA') {
                    cntChip0 += 1;
                }

                // Aplicar filtro por periodo si est√° activo
                const periodoNorm = (reg.periodo || '').toString().trim().toUpperCase() || 'ANUAL';
                if (filtroPeriodo && periodoNorm !== filtroPeriodo) return;

                // Aplicar filtro por rango si est√° activo (solo vigentes), rangos: 60‚Äì31, 30‚Äì16, 15‚Äì1
                // Importante: SOLO filtra ANUAL; si el filtroPeriodo fuerza POST-TRABAJO o REPARACION, no aplica rangos
                if (filtroRango && esAnualReg && (!filtroPeriodo || filtroPeriodo === 'ANUAL')) {
                    if (filtroRango === '0') {
                        if (estado !== 'VENCIDA') return;
                    } else if (filtroRango === 'gt60') {
                        if (estado !== 'VIGENTE' || diasNum === null || !(diasNum > 60)) return;
                    } else {
                        if (estado !== 'VIGENTE' || diasNum === null || diasNum < 1) return;
                        if (filtroRango === '60' && !(diasNum >= 31 && diasNum <= 60)) return;
                        if (filtroRango === '30' && !(diasNum >= 16 && diasNum <= 30)) return;
                        if (filtroRango === '15' && !(diasNum >= 1 && diasNum <= 15)) return;
                    }
                }

                // Contadores alineados al dashboard (despu√©s de calcular diasNum):
                // - "Por realizar" = pruebas ANUALES vigentes cuyo dProx est√° entre 0 y 60 d√≠as (suma de 60‚Äì30, 30‚Äì15, 15‚Äì0)
                // - "Vencidas" = pruebas ANUALES con pr√≥xima ya pasada (estado VENCIDA)
                if (esAnualReg && estado === 'VIGENTE' && diasNum !== null && diasNum >= 0 && diasNum <= 60) {
                    cntPend += 1;
                }
                if (esAnualReg && estado === 'VENCIDA') {
                    cntVenc += 1;
                }

                // Badge visual seg√∫n estado, d√≠as restantes y resultado (solo presentaci√≥n)
                const resultadoStr = (reg.resultado || '').toString().trim().toUpperCase();
                let badgeEstado;

                // Prioridad visual: resultado RECHAZADA => Inoperable
                if (resultadoStr === 'RECHAZADA') {
                    badgeEstado = '<span title="Resultado RECHAZADA: equipo inoperable" style="padding:0.1rem 0.5rem; border-radius:999px; background:#fee2e2; color:#b91c1c; font-size:0.75rem;">Inoperable</span>';
                } else if (estado === 'VENCIDA') {
                    badgeEstado = '<span title="Prueba vencida: la pr√≥xima fecha ya pas√≥" style="padding:0.1rem 0.5rem; border-radius:999px; background:#fee2e2; color:#b91c1c; font-size:0.75rem;">Vencida</span>';
                } else if (estado !== 'VIGENTE') {
                    const etiqueta = esAnualReg ? 'Sin fecha' : 'N/A';
                    badgeEstado = `<span title="Sin informaci√≥n de pr√≥xima prueba" style="padding:0.1rem 0.5rem; border-radius:999px; background:#e5e7eb; color:#374151; font-size:0.75rem;">${etiqueta}</span>`;
                } else {
                    // VIGENTE: ajustar solo apariencia por rango de d√≠as
                    if (diasNum === null) {
                        badgeEstado = '<span title="Prueba vigente" style="padding:0.1rem 0.5rem; border-radius:999px; background:#dcfce7; color:#166534; font-size:0.75rem;">Vigente</span>';
                    } else if (diasNum >= 30 && diasNum <= 60) {
                        badgeEstado = '<span title="Pr√≥ximo a caducar (60 a 30 d√≠as para la pr√≥xima prueba)" style="padding:0.1rem 0.5rem; border-radius:999px; background:#eff6ff; color:#1d4ed8; font-size:0.75rem;">Pr√≥ximo a caducar</span>';
                    } else if (diasNum >= 15 && diasNum < 30) {
                        badgeEstado = '<span title="Pr√≥ximo a caducar (30 a 15 d√≠as para la pr√≥xima prueba)" style="padding:0.1rem 0.5rem; border-radius:999px; background:#fef3c7; color:#b45309; font-size:0.75rem;">Pr√≥ximo a caducar</span>';
                    } else if (diasNum >= 0 && diasNum < 15) {
                        badgeEstado = '<span title="Pr√≥ximo a caducar (menos de 15 d√≠as para la pr√≥xima prueba)" style="padding:0.1rem 0.5rem; border-radius:999px; background:#fee2e2; color:#b91c1c; font-size:0.75rem;">Pr√≥ximo a caducar</span>';
                    } else {
                        // Vigente pero fuera de esos rangos (m√°s de 60 d√≠as, etc.)
                        badgeEstado = '<span title="Prueba vigente" style="padding:0.1rem 0.5rem; border-radius:999px; background:#dcfce7; color:#166534; font-size:0.75rem;">Vigente</span>';
                    }
                }

                const idx = filasVisibles.length;
                filasVisibles.push(reg);

                const periodoActual = (reg.periodo || '').toString().trim().toUpperCase();
                const esAdmin = !!window.isAdmin;
                const periodoTexto = periodoActual || '';

                const esEditable = !!(window.isAdmin || window.isDirector || window.isSupervisor);
                const celdaPeriodo = esEditable
                    ? `<select class="pl-periodo" data-id="${reg.id || ''}">
                            <option value=""></option>
                            <option value="ANUAL" ${periodoActual === 'ANUAL' || !periodoActual ? 'selected' : ''}>Anual</option>
                            <option value="POST-TRABAJO" ${periodoActual === 'POST-TRABAJO' ? 'selected' : ''}>Post-trabajo</option>
                            <option value="REPARACION" ${periodoActual === 'REPARACION' ? 'selected' : ''}>Reparaci√≥n</option>
                       </select>`
                    : periodoTexto;

                const textoPrueba = (reg.prueba || reg.pruebaTipo || '').toString();
                const celdaPrueba = esEditable
                    ? `<input type="text" class="pl-prueba" data-id="${reg.id || ''}" value="${textoPrueba.replace(/"/g, '&quot;')}">`
                    : textoPrueba;

                const textoNoRep = (reg.noReporte || '').toString();
                const celdaNoRep = esEditable
                    ? `<input type="text" class="pl-norep" required data-id="${reg.id || ''}" data-prev="$
                    {textoNoRep.replace(/"/g, '&quot;')}" value="${textoNoRep.replace(/"/g, '&quot;')}">`
    : textoNoRep;

                const resultadoActual = (reg.resultado || '').toString();
                const celdaResultado = esEditable
                    ? `<select class="pl-resultado" data-id="${reg.id || ''}">
                            <option value=""></option>
                            <option value="ACEPTADA" ${resultadoActual === 'ACEPTADA' ? 'selected' : ''}>ACEPTADA</option>
                            <option value="RECHAZADA" ${resultadoActual === 'RECHAZADA' ? 'selected' : ''}>RECHAZADA</option>
                       </select>`
                    : resultadoActual;

                fila.innerHTML = `
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${permitirEliminar ? `<input type="checkbox" class="prueba-select" data-idx="${idx}">` : ``}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${reg.fechaRealizacion || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${proximaStr}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${celdaPeriodo}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${badgeEstado}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${diasParaProxima}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.equipo || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.producto || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.descripcion || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${celdaPrueba}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.area || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb; white-space:nowrap;">${celdaNoRep}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${celdaResultado}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.emisor || ''}</td>
                    <td style="padding:0.35rem; border-bottom:1px solid #e5e7eb;">${reg.tecnico || ''}</td>
                `;

                fila.style.cursor = 'pointer';
                // Evitar que interacciones con controles activen el toggle de fila
                fila.querySelectorAll('input, select, button, a, label').forEach(el => {
                    el.addEventListener('click', (e) => e.stopPropagation());
                    el.addEventListener('mousedown', (e) => e.stopPropagation());
                });
                fila.addEventListener('click', () => {
                    toggleDetalleInline(fila, reg);
                });

                tbodyListado.appendChild(fila);
                cntHist += 1;
            });

            if (!cntHist && msgListado) msgListado.style.display = 'block';
            if (lblPend) lblPend.textContent = `${cntPend} por realizar`;
            if (lblVenc) lblVenc.textContent = `${cntVenc} vencida${cntVenc === 1 ? '' : 's'}`;
            if (lblHist) lblHist.textContent = `${cntHist} en hist√≥rico`;

            const lblAlertGT60 = document.getElementById('pruebas-alert-gt60');
            const lblAlert0 = document.getElementById('pruebas-alert-0');
            if (lblAlertGT60) lblAlertGT60.textContent = String(cntChipGT60);
            if (lblAlert60)   lblAlert60.textContent   = String(cntChip60);
            if (lblAlert30)   lblAlert30.textContent   = String(cntChip30);
            if (lblAlert15)   lblAlert15.textContent   = String(cntChip15);
            if (lblAlert0)    lblAlert0.textContent    = String(cntChip0);

            // Reiniciar checkbox de selecci√≥n global
            if (chkSelectTodos) chkSelectTodos.checked = false;

            // Guardar referencia a filasVisibles en el tbody para exportaci√≥n
            tbodyListado._filasVisibles = filasVisibles;
        }

        if (inputBuscar) {
            inputBuscar.addEventListener('input', () => {
                render();
            });
        }

        function actualizarChipsUI() {
            [chipGT60, chip60, chip30, chip15, chip0].forEach(ch => ch && ch.classList.remove('chip-active'));
            if (filtroRango === 'gt60' && chipGT60) chipGT60.classList.add('chip-active');
            if (filtroRango === '60' && chip60) chip60.classList.add('chip-active');
            if (filtroRango === '30' && chip30) chip30.classList.add('chip-active');
            if (filtroRango === '15' && chip15) chip15.classList.add('chip-active');
            if (filtroRango === '0' && chip0) chip0.classList.add('chip-active');
        }

        function toggleFiltro(r) {
            filtroRango = (filtroRango === r) ? null : r;
            actualizarChipsUI();
            render();
        }

        if (chipGT60) chipGT60.addEventListener('click', () => toggleFiltro('gt60'));
        if (chip60)  chip60.addEventListener('click', () => toggleFiltro('60'));
        if (chip30) chip30.addEventListener('click', () => toggleFiltro('30'));
        if (chip15) chip15.addEventListener('click', () => toggleFiltro('15'));
        if (chip0)  chip0.addEventListener('click', () => toggleFiltro('0'));

        actualizarChipsUI();
        render();

        if (permitirEliminar && chkSelectTodos) {
            chkSelectTodos.addEventListener('change', () => {
                const checks = tbodyListado.querySelectorAll('.prueba-select');
                checks.forEach(chk => {
                    chk.checked = chkSelectTodos.checked;
                });
            });
        }

        function obtenerSeleccionadas() {
            const filas = tbodyListado._filasVisibles || [];
            const checks = tbodyListado.querySelectorAll('.prueba-select:checked');
            const seleccionadas = [];
            checks.forEach(chk => {
                const idx = parseInt(chk.getAttribute('data-idx') || '-1', 10);
                if (!isNaN(idx) && idx >= 0 && idx < filas.length) {
                    seleccionadas.push(filas[idx]);
                }
            });
            // Si no hay selecci√≥n expl√≠cita, usar todas las visibles
            return seleccionadas.length ? seleccionadas : filas;
        }

        async function actualizarCampoPrueba(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = getFirestore(app);
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { prueba: nuevoValor, pruebaTipo: nuevoValor });

                // Actualizar en memoria
                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, prueba: nuevoValor, pruebaTipo: nuevoValor };
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar la prueba/calibraci√≥n para id ' + id, e);
                alert('No se pudo guardar el cambio de Prueba / Calib. Revisa la consola para m√°s detalles.');
            }
        }

        async function actualizarCampoNoReporte(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = getFirestore(app);
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { noReporte: nuevoValor });

                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, noReporte: nuevoValor };
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar el No. reporte / cert. para id ' + id, e);
                alert('No se pudo guardar el cambio de No. reporte / cert. Revisa la consola para m√°s detalles.');
            }
        }

        async function actualizarCampoResultado(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = getFirestore(app);
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { resultado: nuevoValor });

                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, resultado: nuevoValor };
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar el Resultado para id ' + id, e);
                alert('No se pudo guardar el cambio de Resultado. Revisa la consola para m√°s detalles.');
            }
        }

        async function actualizarCampoPeriodo(id, nuevoValor) {
            if (!id) return;
            try {
                const { getFirestore, doc, updateDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );
                const db = getFirestore(app);
                const ref = doc(db, 'pruebas', id);
                await updateDoc(ref, { periodo: nuevoValor || '' });

                pruebas = pruebas.map(reg => {
                    if (reg && reg.id === id) {
                        return { ...reg, periodo: nuevoValor || '' };
                    }
                    return reg;
                });
            } catch (e) {
                console.error('No se pudo actualizar el Periodo para id ' + id, e);
                alert('No se pudo guardar el cambio de Periodo. Revisa la consola para m√°s detalles.');
            }
        }

        function exportarCsv() {
            const filas = obtenerSeleccionadas();
            if (!filas.length) {
                alert('No hay pruebas para exportar.');
                return;
            }

            const encabezados = [
                'FechaRealizacion',
                'Proxima',
                'Estado',
                'DiasParaProxima',
                'Equipo',
                'Producto',
                'Descripcion',
                'Prueba',
                'Area',
                'NoReporte',
                'Resultado',
                'Emisor',
                'Tecnico'
            ];

            function esc(val) {
                const s = String(val ?? '');
                if (/[",;\n]/.test(s)) {
                    return '"' + s.replace(/"/g, '""') + '"';
                }
                return s;
            }

            const hoy = new Date();
            const yyyy = hoy.getFullYear();
            const mm = String(hoy.getMonth() + 1).padStart(2, '0');
            const dd = String(hoy.getDate()).padStart(2, '0');

            const lineas = [];
            lineas.push(encabezados.join(','));

            filas.forEach(reg => {
                const clasif = clasificarPrueba(reg);
                let dias = '';
                if (clasif.proxima) {
                    const d0 = hoySinHora();
                    const diffMs = clasif.proxima.getTime() - d0.getTime();
                    let d = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    if (d < 0) d = 0;
                    dias = String(d);
                }

                const filaCsv = [
                    reg.fechaRealizacion || '',
                    reg.proxima || '',
                    clasif.estado || '',
                    dias,
                    reg.equipo || '',
                    reg.producto || '',
                    reg.descripcion || '',
                    reg.prueba || reg.pruebaTipo || '',
                    reg.area || '',
                    reg.noReporte || '',
                    reg.resultado || '',
                    reg.emisor || '',
                    reg.tecnico || ''
                ].map(esc).join(',');

                lineas.push(filaCsv);
            });

            const blob = new Blob([lineas.join('\n')], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pruebas_${yyyy}${mm}${dd}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        if (btnExportCsv) {
            btnExportCsv.addEventListener('click', exportarCsv);
        }

        async function eliminarSeleccionadas() {
            const filas = obtenerSeleccionadas();
            if (!filas.length) {
                alert('No hay pruebas seleccionadas para eliminar.');
                return;
            }

            const confirmar = window.confirm('Se eliminar√°n ' + filas.length + ' pruebas seleccionadas de Firestore. Esta acci√≥n no se puede deshacer. ¬øContinuar?');
            if (!confirmar) return;

            const idsAEliminar = new Set(
                filas
                    .map(reg => (reg && reg.id ? String(reg.id) : ''))
                    .filter(id => !!id)
            );

            if (!idsAEliminar.size) {
                alert('Las pruebas actuales no tienen identificador de Firestore, no se pueden eliminar remotamente.');
                return;
            }

            try {
                const { getFirestore, doc, deleteDoc } = await import(
                    'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'
                );

                const db = getFirestore(app);

                for (const id of idsAEliminar) {
                    try {
                        const ref = doc(db, 'pruebas', id);
                        await deleteDoc(ref);
                    } catch (e) {
                        console.warn('No se pudo eliminar la prueba con id ' + id, e);
                    }
                }

                // Filtrar las pruebas en memoria y volver a renderizar
                pruebas = pruebas.filter(reg => !(reg && reg.id && idsAEliminar.has(String(reg.id))));
                render();
                alert('Eliminaci√≥n completada.');
            } catch (e) {
                console.error('Error al eliminar pruebas desde Firestore', e);
                alert('Ocurri√≥ un error al eliminar las pruebas. Revisa la consola para m√°s detalles.');
            }
        }

        if (btnEliminar) {
            btnEliminar.addEventListener('click', eliminarSeleccionadas);
        }

   // Delegaci√≥n de eventos para inputs/selects editables de prueba, noReporte y resultado
tbodyListado.addEventListener('change', (ev) => {
  const target = ev.target;
  if (!(target instanceof HTMLInputElement) && !(target instanceof HTMLSelectElement)) return;

  const id = target.getAttribute('data-id') || '';
  const valor = (target.value || '').trim();

  if (target.classList.contains('pl-prueba')) {
    actualizarCampoPrueba(id, valor);
  } else if (target.classList.contains('pl-norep')) {
    if (!valor) {
      alert('El campo "No. reporte / cert." es requerido.');
      const prev = target.getAttribute('data-prev') || '';
      target.value = prev;
      return;
    }
    actualizarCampoNoReporte(id, valor);
    target.setAttribute('data-prev', valor);
  } else if (target.classList.contains('pl-resultado')) {
    actualizarCampoResultado(id, valor);
  } else if (target.classList.contains('pl-periodo')) {
    actualizarCampoPeriodo(id, valor || '');
  }
});

// Asegura ejecutar un render final tras registrar handlers
render();
}
</script>
</body>
</html>
